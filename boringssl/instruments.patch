diff --git a/crypto/fipsmodule/rsa/padding.c b/crypto/fipsmodule/rsa/padding.c
index b7998fe3..7bf724cc 100644
--- a/crypto/fipsmodule/rsa/padding.c
+++ b/crypto/fipsmodule/rsa/padding.c
@@ -146,6 +146,7 @@ int RSA_padding_check_PKCS1_type_1(uint8_t *out, size_t *out_len,
 }
 
 static int rand_nonzero(uint8_t *out, size_t len) {
+/*
   if (!RAND_bytes(out, len)) {
     return 0;
   }
@@ -157,6 +158,10 @@ static int rand_nonzero(uint8_t *out, size_t len) {
       }
     }
   }
+*/
+  for (size_t i = 0; i < len; i++) {
+    out[i] = '\x20';
+  }
 
   return 1;
 }
@@ -349,9 +354,14 @@ int RSA_padding_add_PKCS1_OAEP_mgf1(uint8_t *to, size_t to_len,
   OPENSSL_memset(db + mdlen, 0, emlen - from_len - 2 * mdlen - 1);
   db[emlen - from_len - mdlen - 1] = 0x01;
   OPENSSL_memcpy(db + emlen - from_len - mdlen, from, from_len);
+/*
   if (!RAND_bytes(seed, mdlen)) {
     return 0;
   }
+*/
+  for (size_t i = 0; i < mdlen; i++) {
+    seed[i] = '\x21';
+  }
 
   uint8_t *dbmask = OPENSSL_malloc(emlen - mdlen);
   if (dbmask == NULL) {
@@ -639,9 +649,14 @@ int RSA_padding_add_PKCS1_PSS_mgf1(const RSA *rsa, unsigned char *EM,
       OPENSSL_PUT_ERROR(RSA, ERR_R_MALLOC_FAILURE);
       goto err;
     }
+/*
     if (!RAND_bytes(salt, sLen)) {
       goto err;
     }
+*/
+    for (size_t i = 0; i < sLen; i++) {
+      salt[i] = '\x22';
+    }
   }
   maskedDBLen = emLen - hLen - 1;
   H = EM + maskedDBLen;
diff --git a/include/openssl/curve25519.h b/include/openssl/curve25519.h
index a455389c..b6b9612d 100644
--- a/include/openssl/curve25519.h
+++ b/include/openssl/curve25519.h
@@ -41,6 +41,8 @@ extern "C" {
 // generated, publicâ€“private key pair.
 OPENSSL_EXPORT void X25519_keypair(uint8_t out_public_value[32],
                                    uint8_t out_private_key[32]);
+OPENSSL_EXPORT void X25519_keypair_client(uint8_t out_public_value[32],
+                                          uint8_t out_private_key[32]);
 
 // X25519 writes a shared key to |out_shared_key| that is calculated from the
 // given private key and the peer's public value. It returns one on success and
diff --git a/ssl/handshake.cc b/ssl/handshake.cc
index 963038f5..aacb934b 100644
--- a/ssl/handshake.cc
+++ b/ssl/handshake.cc
@@ -405,7 +405,11 @@ uint16_t ssl_get_grease_value(SSL_HANDSHAKE *hs,
   // connection. The latter is so the second ClientHello matches after
   // HelloRetryRequest and so supported_groups and key_shares are consistent.
   if (!hs->grease_seeded) {
+/*
     RAND_bytes(hs->grease_seed, sizeof(hs->grease_seed));
+*/
+    const char grease_seed_override[] = "\x01\x12\x23\x34\x45\x56\x67\x78\x89\x9a";
+    OPENSSL_memcpy(hs->grease_seed, grease_seed_override, sizeof(hs->grease_seed));
     hs->grease_seeded = true;
   }
 
diff --git a/ssl/handshake_client.cc b/ssl/handshake_client.cc
index e46b39f9..9c584082 100644
--- a/ssl/handshake_client.cc
+++ b/ssl/handshake_client.cc
@@ -411,9 +411,14 @@ static enum ssl_hs_wait_t do_start_connect(SSL_HANDSHAKE *hs) {
     }
   }
 
+/*
   if (!RAND_bytes(ssl->s3->client_random, sizeof(ssl->s3->client_random))) {
     return ssl_hs_error;
   }
+*/
+  const char *client_random_override = "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+    "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f";
+  OPENSSL_memcpy(ssl->s3->client_random, client_random_override, sizeof(ssl->s3->client_random));
 
   // Initialize a random session ID for the experimental TLS 1.3 variant
   // requiring a session id.
@@ -425,9 +430,14 @@ static enum ssl_hs_wait_t do_start_connect(SSL_HANDSHAKE *hs) {
                    hs->session_id_len);
   } else if (hs->max_version >= TLS1_3_VERSION) {
     hs->session_id_len = sizeof(hs->session_id);
+/*
     if (!RAND_bytes(hs->session_id, hs->session_id_len)) {
       return ssl_hs_error;
     }
+*/
+    const char *fake_session_id_override = "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
+      "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff";
+    OPENSSL_memcpy(hs->session_id, fake_session_id_override, hs->session_id_len);
   }
 
   if (!ssl_write_client_hello(hs)) {
diff --git a/ssl/internal.h b/ssl/internal.h
index 22189920..e634d620 100644
--- a/ssl/internal.h
+++ b/ssl/internal.h
@@ -960,6 +960,7 @@ class SSLKeyShare {
 
   // Offer generates a keypair and writes the public value to
   // |out_public_key|. It returns true on success and false on error.
+  virtual bool OfferClient(CBB *out_public_key) PURE_VIRTUAL;
   virtual bool Offer(CBB *out_public_key) PURE_VIRTUAL;
 
   // Accept performs a key exchange against the |peer_key| generated by |offer|.
diff --git a/ssl/ssl_aead_ctx.cc b/ssl/ssl_aead_ctx.cc
index 335f6f48..e3671e90 100644
--- a/ssl/ssl_aead_ctx.cc
+++ b/ssl/ssl_aead_ctx.cc
@@ -303,6 +303,16 @@ bool SSLAEADContext::Open(Span<uint8_t> *out, uint8_t type,
       nonce[i] ^= fixed_nonce_[i];
     }
   }
+  printf("READ NONCE:");
+  for (size_t i = 0; i < nonce_len; i++) {
+    printf("%02x", nonce[i]);
+  }
+  printf("\n");
+  printf("READ AAD:");
+  for (size_t i = 0; i < ad.size(); i++) {
+    printf("%02x", ad.data()[i]);
+  }
+  printf("\n");
 
   // Decrypt in-place.
   size_t len;
@@ -311,6 +321,11 @@ bool SSLAEADContext::Open(Span<uint8_t> *out, uint8_t type,
                          ad.size())) {
     return false;
   }
+  printf("READ PLAINTEXT:");
+  for (size_t i = 0; i < len; i++) {
+    printf("%02x", in.data()[i]);
+  }
+  printf("\n");
   *out = in.subspan(0, len);
   return true;
 }
@@ -391,6 +406,16 @@ bool SSLAEADContext::SealScatter(uint8_t *out_prefix, uint8_t *out,
       nonce[i] ^= fixed_nonce_[i];
     }
   }
+  printf("WRITE NONCE:");
+  for (size_t i = 0; i < nonce_len; i++) {
+    printf("%02x", nonce[i]);
+  }
+  printf("\n");
+  printf("WRITE AAD:");
+  for (size_t i = 0; i < ad.size(); i++) {
+    printf("%02x", ad.data()[i]);
+  }
+  printf("\n");
 
   size_t written_suffix_len;
   bool result = !!EVP_AEAD_CTX_seal_scatter(
diff --git a/ssl/ssl_asn1.cc b/ssl/ssl_asn1.cc
index caccef4d..db1acdbd 100644
--- a/ssl/ssl_asn1.cc
+++ b/ssl/ssl_asn1.cc
@@ -215,7 +215,10 @@ static int SSL_SESSION_to_bytes_full(const SSL_SESSION *in, CBB *cbb,
       !CBB_add_asn1_octet_string(&session, in->master_key,
                                  in->master_key_length) ||
       !CBB_add_asn1(&session, &child, kTimeTag) ||
+/*
       !CBB_add_asn1_uint64(&child, in->time) ||
+*/
+!CBB_add_asn1_uint64(&child, 1540924764) ||
       !CBB_add_asn1(&session, &child, kTimeoutTag) ||
       !CBB_add_asn1_uint64(&child, in->timeout)) {
     OPENSSL_PUT_ERROR(SSL, ERR_R_MALLOC_FAILURE);
diff --git a/ssl/ssl_key_share.cc b/ssl/ssl_key_share.cc
index 8466eabb..ec61e2be 100644
--- a/ssl/ssl_key_share.cc
+++ b/ssl/ssl_key_share.cc
@@ -72,6 +72,9 @@ class ECKeyShare : public SSLKeyShare {
 
     return true;
   }
+  bool OfferClient(CBB *out) override {
+    return Offer(out);
+  }
 
   bool Finish(Array<uint8_t> *out_secret, uint8_t *out_alert,
               Span<const uint8_t> peer_key) override {
@@ -165,6 +168,11 @@ class X25519KeyShare : public SSLKeyShare {
 
   uint16_t GroupID() const override { return SSL_CURVE_X25519; }
 
+  bool OfferClient(CBB *out) override {
+    uint8_t public_key[32];
+    X25519_keypair_client(public_key, private_key_);
+    return !!CBB_add_bytes(out, public_key, sizeof(public_key));
+  }
   bool Offer(CBB *out) override {
     uint8_t public_key[32];
     X25519_keypair(public_key, private_key_);
diff --git a/ssl/ssl_lib.cc b/ssl/ssl_lib.cc
index 1f648658..86ef9fab 100644
--- a/ssl/ssl_lib.cc
+++ b/ssl/ssl_lib.cc
@@ -414,6 +414,7 @@ void ssl_ctx_get_current_time(const SSL_CTX *ctx,
   if (ctx->current_time_cb != NULL) {
     // TODO(davidben): Update current_time_cb to use OPENSSL_timeval. See
     // https://crbug.com/boringssl/155.
+#if 0
     struct timeval clock;
     ctx->current_time_cb(nullptr /* ssl */, &clock);
     if (clock.tv_sec < 0) {
@@ -424,6 +425,9 @@ void ssl_ctx_get_current_time(const SSL_CTX *ctx,
       out_clock->tv_sec = (uint64_t)clock.tv_sec;
       out_clock->tv_usec = (uint32_t)clock.tv_usec;
     }
+#endif
+    out_clock->tv_sec = 1540925272;
+    out_clock->tv_usec = 123456789;
     return;
   }
 
diff --git a/ssl/ssl_session.cc b/ssl/ssl_session.cc
index 927dd1ba..1bb96989 100644
--- a/ssl/ssl_session.cc
+++ b/ssl/ssl_session.cc
@@ -432,9 +432,18 @@ int ssl_ctx_rotate_ticket_encryption_key(SSL_CTX *ctx) {
     if (!new_key) {
       return 0;
     }
+/*
     RAND_bytes(new_key->name, 16);
     RAND_bytes(new_key->hmac_key, 16);
     RAND_bytes(new_key->aes_key, 16);
+*/
+    const char ticket_name_override[] = "\x01\x06\x09\x11\x16\x19\x21\x26\x29\x31\x36\x39\x41\x46\x49\x51";
+    const char ticket_aes_override[] = "\x02\x06\x09\x11\x16\x19\x21\x26\x29\x31\x36\x39\x41\x46\x49\x51";
+    const char ticket_hmac_override[] = "\x03\x06\x09\x11\x16\x19\x21\x26\x29\x31\x36\x39\x41\x46\x49\x51";
+    OPENSSL_memcpy(new_key->name, ticket_name_override, 16);
+    OPENSSL_memcpy(new_key->hmac_key, ticket_hmac_override, 16);
+    OPENSSL_memcpy(new_key->aes_key, ticket_aes_override, 16);
+
     new_key->next_rotation_tv_sec =
         now.tv_sec + SSL_DEFAULT_TICKET_KEY_ROTATION_INTERVAL;
     if (ctx->ticket_key_current) {
@@ -478,6 +487,10 @@ static int ssl_encrypt_ticket_with_cipher_ctx(SSL_HANDSHAKE *hs, CBB *out,
   SSL_CTX *tctx = hs->ssl->session_ctx.get();
   uint8_t iv[EVP_MAX_IV_LENGTH];
   uint8_t key_name[16];
+
+  const char override_iv[] = "\x03\x06\x09\x13\x16\x19\x23\x26\x29\x33\x36\x39\x43\x46\x49\x53";
+  OPENSSL_memcpy(iv, override_iv, 16);
+
   if (tctx->ticket_key_cb != NULL) {
     if (tctx->ticket_key_cb(hs->ssl, key_name, iv, ctx.get(), hctx.get(),
                             1 /* encrypt */) < 0) {
@@ -489,7 +502,10 @@ static int ssl_encrypt_ticket_with_cipher_ctx(SSL_HANDSHAKE *hs, CBB *out,
       return 0;
     }
     MutexReadLock lock(&tctx->lock);
+/*
     if (!RAND_bytes(iv, 16) ||
+*/
+    if (
         !EVP_EncryptInit_ex(ctx.get(), EVP_aes_128_cbc(), NULL,
                             tctx->ticket_key_current->aes_key, iv) ||
         !HMAC_Init_ex(hctx.get(), tctx->ticket_key_current->hmac_key, 16,
@@ -850,7 +866,7 @@ ssl_session_st::ssl_session_st(const SSL_X509_METHOD *method)
       ticket_age_add_valid(false),
       is_server(false) {
   CRYPTO_new_ex_data(&ex_data);
-  time = ::time(nullptr);
+  time = 1540924764; // override
 }
 
 ssl_session_st::~ssl_session_st() {
@@ -960,7 +976,10 @@ uint64_t SSL_SESSION_set_time(SSL_SESSION *session, uint64_t time) {
     return 0;
   }
 
+  session->time = 1540924764;
+/*
   session->time = time;
+*/
   return time;
 }
 
diff --git a/ssl/t1_lib.cc b/ssl/t1_lib.cc
index 678e4a3b..0b6f3b9b 100644
--- a/ssl/t1_lib.cc
+++ b/ssl/t1_lib.cc
@@ -2182,7 +2182,7 @@ static bool ext_key_share_add_clienthello(SSL_HANDSHAKE *hs, CBB *out) {
   if (!hs->key_share ||
       !CBB_add_u16(&kse_bytes, group_id) ||
       !CBB_add_u16_length_prefixed(&kse_bytes, &key_exchange) ||
-      !hs->key_share->Offer(&key_exchange) ||
+      !hs->key_share->OfferClient(&key_exchange) ||
       !CBB_flush(&kse_bytes)) {
     return false;
   }
diff --git a/ssl/tls13_both.cc b/ssl/tls13_both.cc
index a02d35d7..54476067 100644
--- a/ssl/tls13_both.cc
+++ b/ssl/tls13_both.cc
@@ -567,6 +567,11 @@ enum ssl_private_key_result_t tls13_add_certificate_verify(SSL_HANDSHAKE *hs) {
     ssl_send_alert(ssl, SSL3_AL_FATAL, SSL_AD_INTERNAL_ERROR);
     return ssl_private_key_failure;
   }
+  printf("CERT VERIFY PAYLOAD:");
+  for (size_t i = 0; i < msg.size(); i++) {
+    printf("%02x", msg[i]);
+  }
+  printf("\n");
 
   enum ssl_private_key_result_t sign_result = ssl_private_key_sign(
       hs, sig, &sig_len, max_sig_len, signature_algorithm, msg);
diff --git a/ssl/tls13_enc.cc b/ssl/tls13_enc.cc
index 5e1f19a3..1cd8ea55 100644
--- a/ssl/tls13_enc.cc
+++ b/ssl/tls13_enc.cc
@@ -168,6 +168,16 @@ bool tls13_set_traffic_key(SSL *ssl, enum evp_aead_direction_t direction,
     return false;
   }
 
+  if (direction) {
+    printf("WRITE KEY:");
+  } else {
+    printf("READ KEY:");
+  }
+  for (size_t i = 0; i < key_len; i++) {
+    printf("%02x", key[i]);
+  }
+  printf("\n");
+
   UniquePtr<SSLAEADContext> traffic_aead =
       SSLAEADContext::Create(direction, session->ssl_version, SSL_is_dtls(ssl),
                              session->cipher, MakeConstSpan(key, key_len),
diff --git a/ssl/tls13_server.cc b/ssl/tls13_server.cc
index 0d82d68b..d48c5214 100644
--- a/ssl/tls13_server.cc
+++ b/ssl/tls13_server.cc
@@ -175,9 +175,14 @@ static bool add_new_session_tickets(SSL_HANDSHAKE *hs, bool *out_sent_tickets) {
       return false;
     }
 
+/*
     if (!RAND_bytes((uint8_t *)&session->ticket_age_add, 4)) {
       return false;
     }
+*/
+    const char *session_ticket_age_add_override = "\x01\x02\x03\x04";
+    OPENSSL_memcpy(&session->ticket_age_add, session_ticket_age_add_override, 4);
+
     session->ticket_age_add_valid = true;
     if (ssl->enable_early_data) {
       session->ticket_max_early_data = kMaxEarlyDataAccepted;
@@ -560,12 +565,16 @@ static enum ssl_hs_wait_t do_read_second_client_hello(SSL_HANDSHAKE *hs) {
 static enum ssl_hs_wait_t do_send_server_hello(SSL_HANDSHAKE *hs) {
   SSL *const ssl = hs->ssl;
 
+  const char *server_random_override = "\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
+    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f";
+  OPENSSL_memcpy(ssl->s3->server_random, server_random_override, sizeof(ssl->s3->server_random));
+
   // Send a ServerHello.
   ScopedCBB cbb;
   CBB body, extensions, session_id;
   if (!ssl->method->init_message(ssl, cbb.get(), &body, SSL3_MT_SERVER_HELLO) ||
       !CBB_add_u16(&body, TLS1_2_VERSION) ||
-      !RAND_bytes(ssl->s3->server_random, sizeof(ssl->s3->server_random)) ||
+      /* !RAND_bytes(ssl->s3->server_random, sizeof(ssl->s3->server_random)) || */
       !CBB_add_bytes(&body, ssl->s3->server_random, SSL3_RANDOM_SIZE) ||
       !CBB_add_u8_length_prefixed(&body, &session_id) ||
       !CBB_add_bytes(&session_id, hs->session_id, hs->session_id_len) ||
diff --git a/third_party/fiat/curve25519.c b/third_party/fiat/curve25519.c
index 58a5ed04..aca3f420 100644
--- a/third_party/fiat/curve25519.c
+++ b/third_party/fiat/curve25519.c
@@ -3175,6 +3175,9 @@ static void x25519_scalar_mult(uint8_t out[32], const uint8_t scalar[32],
 
 void X25519_keypair(uint8_t out_public_value[32], uint8_t out_private_key[32]) {
   RAND_bytes(out_private_key, 32);
+  const char *server_key_override = "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
+    "\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf";
+  OPENSSL_memcpy(out_private_key, server_key_override, 32);
 
   // All X25519 implementations should decode scalars correctly (see
   // https://tools.ietf.org/html/rfc7748#section-5). However, if an
@@ -3196,6 +3199,19 @@ void X25519_keypair(uint8_t out_public_value[32], uint8_t out_private_key[32]) {
   X25519_public_from_private(out_public_value, out_private_key);
 }
 
+void X25519_keypair_client(uint8_t out_public_value[32], uint8_t out_private_key[32]) {
+  RAND_bytes(out_private_key, 32);
+  const char *client_key_override = "\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f"
+    "\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f";
+  OPENSSL_memcpy(out_private_key, client_key_override, 32);
+
+  out_private_key[0] |= ~248;
+  out_private_key[31] &= ~64;
+  out_private_key[31] |= ~127;
+
+  X25519_public_from_private(out_public_value, out_private_key);
+}
+
 int X25519(uint8_t out_shared_key[32], const uint8_t private_key[32],
            const uint8_t peer_public_value[32]) {
   static const uint8_t kZeros[32] = {0};
