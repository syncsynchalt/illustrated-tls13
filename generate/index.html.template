<!doctype html>
<html>

<head>
	<title>The Illustrated TLS 1.3 Connection: Every Byte Explained</title>
	<meta charset="utf-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/>
	<meta name="format-detection" content="telephone=no"/>
	<meta name="title" content="The Illustrated TLS 1.3 Connection"/>
	<meta name="description" content="Every byte of a TLS 1.3 connection explained and reproduced"/>
	<link rel="stylesheet" href="frombootstrap.css?bustin"/>
	<link rel="stylesheet" href="illustrated.css?bustin"/>
	<script src="illustrated.js?bustin"></script>

	<!-- Facebook Meta Tags -->
	<meta property="og:url" content="https://tls13.ulfheim.net/">
	<meta property="og:type" content="website">
	<meta property="og:title" content="The Illustrated TLS 1.3 Connection">
	<meta property="og:description" content="Every byte of a TLS connection explained and reproduced">
	<meta property="og:image" content="https://tls13.ulfheim.net/images/og.png?bustin">

	<!-- Twitter Meta Tags -->
	<meta name="twitter:card" content="summary_large_image">
	<meta property="twitter:domain" content="tls13.ulfheim.net">
	<meta property="twitter:url" content="https://tls13.ulfheim.net/">
	<meta name="twitter:title" content="The Illustrated TLS 1.3 Connection">
	<meta name="twitter:description" content="Every byte of a TLS connection explained and reproduced">
	<meta name="twitter:image" content="https://tls13.ulfheim.net/images/og.png?bustin">

	<!-- favicons -->
	<link rel="apple-touch-icon" sizes="152x152" href="favicon/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">
	<link rel="manifest" href="favicon/site.webmanifest">
	<link rel="mask-icon" href="favicon/safari-pinned-tab.svg" color="#5bbad5">
	<link rel="shortcut icon" href="favicon.ico">
	<meta name="msapplication-TileColor" content="#da532c">
	<meta name="msapplication-config" content="favicon/browserconfig.xml">
	<meta name="theme-color" content="#ffffff">
</head>

<body class="illustrated">
<div class="header">
	<a href="https://quic.ulfheim.net">QUIC</a>
	<a class="this-page" href="https://tls13.ulfheim.net">TLS 1.3</a>
	<a href="https://tls12.ulfheim.net">TLS 1.2</a>
</div>
<h1>The Illustrated TLS 1.3 Connection</h1>
<div class="container">

	<h3>Every byte explained and reproduced</h3>

	<div class="outerblock">
	<p><em>Note: Updated April 2022 to move from an experimental
	library to OpenSSL 3.0.1. The original version of this page is
	archived <a href="archive/">here</a>.</em>
	</div>

	<div class="outerblock">
	<p>In this demonstration a client connects to a server,
	negotiates a TLS 1.3 session, sends "ping", receives "pong",
	and then terminates the session. Click below to begin
	exploring.</p>
	</div>

<div class="rec-outer">
<div class="calculation client">
<div class="rec-label">Client Key Exchange Generation</div>
<img class="illustration" src="images/key6.png" width="105" height="250"/>
<div class="rec-explanation">
	<p>The client begins by calculating a private/public keypair
	for key exchange.  Key exchange is a technique
	where two parties can agree on the same number without
	an eavesdropper being able to tell what the number is.
	It will do this via an elliptical curve method, using the x25519 curve.
	<p>
	Explaining and understanding the details of ECDHE key exchange
	is outside the scope of this document. I found Andrea Corbellini's
	<a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">
	Elliptic Curve Cryptography: a gentle introduction</a> a good resource for this.
	<p>
	The private key is chosen by selecting an integer between
	0 and 2<sup>256</sup>-1.  It does this by generating 32
	bytes (256 bits) of random data.  The
	<a href="files/client-ephemeral-private.key" download="client-ephemeral-private.key">private key</a>
	selected is:

	<pre class="ind2"><tt class="longboi"
	>202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f</tt></pre>

	The <a href="files/client-ephemeral-public.key" download="client-ephemeral-public.key">public key</a>
	is chosen by "adding" the point represented by x=9 on the x25519 curve
	to itself "private key" number of times (you don't need to understand this).
	The public key calculated is:

	<pre class="ind2"><tt class="longboi"
	>358072d6365880d1aeea329adf9121383851ed21a28e3b75e965d0d2cd166254</tt></pre>

	The public key calculation can be confirmed at the command line:
	<codesample>
<pre><code>### requires openssl 1.1.0 or higher
$ openssl pkey -noout -text &lt; client-ephemeral-private.key

X25519 Private-Key:
priv:
    20:21:22:23:24:25:26:27:28:29:2a:2b:2c:2d:2e:
    2f:30:31:32:33:34:35:36:37:38:39:3a:3b:3c:3d:
    3e:3f
pub:
    35:80:72:d6:36:58:80:d1:ae:ea:32:9a:df:91:21:
    38:38:51:ed:21:a2:8e:3b:75:e9:65:d0:d2:cd:16:
    62:54
</code></pre>
	</codesample>
</div>
</div>
</div>

<div class="rec-outer">
<div class="record client">
<div class="rec-label">Client Hello</div>
<img class="illustration" src="images/key1.png" width="135" height="250"/>
<div class="rec-explanation">
	The session begins with the client saying "Hello".
	The client provides information including the following:
	<ul>
	<li>client random data (used later in the handshake)
	<li>a list of cipher suites that the client supports
	<li>a list of public keys that the server might find suitable for key exchange
	<li>protocol versions that the client can support
	</ul>
</div>
%file ../captures/caps/clienthello
<span class="record-data">
	<span class="string">
		<span class="label">Record Header</span>
		<span class="bytes">
%next 5
%bytes
		</span>
		<div class="explanation">
			TLS sessions are broken into the sending
			and receiving of "records", which are blocks
			of data with a type, a protocol version,
			and a length.
			<ul>
			<li><tt>%0</tt> - type is 0x16 (handshake record)
			<li><tt>%1 %2</tt> - protocol version is "3,1" (also known as TLS 1.0)
			<li><tt>%3 %4</tt> - %nn3 bytes of handshake message follows
			</ul>
			Interestingly the version in this record
			is "3,1" (TLS 1.0) instead of "3,4" (TLS 1.3).
			This is done for interoperability with earlier
			implementations.
		</div>
	</span>

	<span class="string">
		<span class="label">Handshake Header</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<ul>
			<li><tt>%0</tt> - handshake message type 0x01 (client hello)
			<li><tt>%1 %2 %3</tt> - %nnn1 bytes of client hello data follows
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Client Version</span>
		<span class="bytes">
%next 2
%bytes
		</span>
		<div class="explanation">
			A protocol version of "3,3" (meaning TLS 1.2)
			is given.  Because middleboxes have been
			created and widely deployed that do not
			allow protocol versions that
			they do not recognize, the TLS 1.3 session
			must be disguised as a TLS 1.2 session.
			This field is no
			longer used for version negotiation and
			is hardcoded to the 1.2 version.  Instead
			version negotiation is performed using the
			"Supported Versions" extension below.
			<br/><br/>
			The unusual version number ("3,3" representing
			TLS 1.2) is due to TLS 1.0 being a minor
			revision of the SSL 3.0 protocol.  Therefore
			TLS 1.0 is represented by "3,1", TLS 1.1 is
			"3,2", and so on.
		</div>
	</span>

	<span class="string">
		<span class="label">Client Random</span>
		<span class="bytes">
%next 32
%bytes
		</span>
		<div class="explanation">
			The client provides 32 bytes of random data.  This data will be used later in the session.
			In this example we've made the random data a predictable string.
		</div>
	</span>

	<span class="string">
		<span class="label">Session ID</span>
		<span class="bytes">
%next 33
%bytes
		</span>
		<div class="explanation">
			In previous versions of TLS the client could
			provide an ID of a previously negotiated
			session, which allows the server and client
			to skip the time and cost of negotiating new keys.
			<br/><br/>
			In TLS 1.3 this "session resume" is done via the more flexible
			PSK (pre-shared keys) mechanism, so this
			field is no longer needed for that purpose.
			Instead a non-empty value in this field is
			used to trigger "middlebox compatibility
			mode" which helps TLS 1.3 sessions to be
			disguised as resumed TLS 1.2 sessions.  The
			client has generated random data to populate
			this field.
			<ul>
			<li><tt>%0</tt> - %n0 bytes of session ID follow
			<li><tt>%1 %2 ... %-2 %-1</tt> - fake session ID
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Cipher Suites</span>
		<span class="bytes">
%next 10
%bytes
		</span>
		<div class="explanation">
			The client provides an ordered list of which
			cipher suites it will support for encryption.
			The list is in the order preferred by the
			client, with highest preference first.
			<br/><br/>
			In TLS 1.3 the list of possible cipher
			suites has been greatly reduced.  All the
			remaining suites are AEAD algorithms which
			provide stronger encryption guarantees than
			many previous suites with an easier all-in-one
			implementation.
			<ul>
			<li><tt>%0 %1</tt> - %nn0 bytes of cipher suite data
			<li><tt>13 02</tt> - assigned value for <tt>TLS_AES_256_GCM_SHA384</tt>
			<li><tt>13 03</tt> - assigned value for <tt>TLS_CHACHA20_POLY1305_SHA256</tt>
			<li><tt>13 01</tt> - assigned value for <tt>TLS_AES_128_GCM_SHA256</tt>
			<li><tt>00 ff</tt> - assigned value for <tt>TLS_EMPTY_RENEGOTIATION_INFO_SCSV</tt>
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Compression Methods</span>
		<span class="bytes">
%next 2
%bytes
		</span>
		<div class="explanation">
			Previous versions of TLS supported
			compression, which was found to leak
			information about the encrypted data allowing
			it to be read (see <a href="https://en.wikipedia.org/wiki/CRIME">CRIME</a>).
			<br/><br/>
			TLS 1.3 no longer allows compression, so
			this field is always a single entry with
			the "null" compression method which performs
			no change to the data.
			<ul>
			<li><tt>%0</tt> - %n0 bytes of compression methods
			<li><tt>00</tt> - assigned value for "null" compression
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Extensions Length</span>
		<span class="bytes">
%next 2
%bytes
		</span>
		<div class="explanation">
			The client has provided a list of optional
			extensions which the server can use to
			take action or enable new features.
			<ul>
			<li><tt>%0 %1</tt> - the extensions will take %nn0 bytes of data
			</ul>
			Each extension will start with two bytes
			that indicate which extension it is, followed
			by a two-byte content length field, followed
			by the contents of the extension.
		</div>
	</span>

	<span class="string">
		<span class="label">Extension - Server Name</span>
		<span class="bytes">
%next 28
%bytes
		</span>
		<div class="explanation">
			The client has provided the name of the
			server it is contacting, also known as SNI
			(Server Name Indication).
			<br/><br/>
			Without this extension a HTTPS server would
			not be able to provide service for multiple
			hostnames (virtual hosts) on a single IP address
			because it couldn't know which
			hostname's certificate to send until
			after the TLS session was negotiated and the
			HTTP request was made.
			<ul>
				<li><tt>00 00</tt> - assigned value for extension "server name"
				<li><tt>%2 %3</tt> - %nn2 bytes of "server name" extension data follows
				<li><tt>%4 %5</tt> - %nn4 bytes of first (and only) list entry follows
				<li><tt>%6</tt> - list entry is type 0x00 "DNS hostname"
				<li><tt>%7 %8</tt> - %nn7 bytes of hostname follows
				<li><tt>%9 %10 %11 ... %-3 %-2 %-1</tt> - "example.ulfheim.net"
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Extension - EC Point Formats</span>
		<span class="bytes">
%next 8
%bytes
		</span>
		<div class="explanation">
			The client has indicated that it supports receiving
			elliptical curve data points in the following compression formats:
			<ul>
				<li><tt>%0 %1</tt> - assigned value for extension "ec point formats"
				<li><tt>%2 %3</tt> - %nn2 bytes of format types follow
				<li><tt>%4</tt> - %n4 bytes of format types follow
				<li><tt>00</tt> - assigned value for format "uncompressed"
				<li><tt>01</tt> - assigned value for format "ansiX962_compressed_prime"
				<li><tt>02</tt> - assigned value for format "ansiX962_compressed_char2"
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Extension - Supported Groups</span>
		<span class="bytes">
%next 26
%bytes
		</span>
		<div class="explanation">
			The client has indicated that it supports
			elliptic curve (EC) cryptography for ten curve types.
			To make this extension more generic for
			other cryptography types it calls these
			"supported groups" instead of "supported
			curves".
			<br/><br/>
			This list is presented in descending order
			of the client's preference.
			<ul>
				<li><tt>00 0a</tt> - assigned value for extension "supported groups"
				<li><tt>%2 %3</tt> - %nn2 bytes of "supported group" extension data follows
				<li><tt>%4 %5</tt> - %nn4 bytes of data are in the curves list
				<li><tt>00 1d</tt> - assigned value for the curve "x25519"
				<li><tt>00 17</tt> - assigned value for the curve "secp256r1"
				<li><tt>00 1e</tt> - assigned value for the curve "x448"
				<li><tt>00 19</tt> - assigned value for the curve "secp521r1"
				<li><tt>00 18</tt> - assigned value for the curve "secp384r1"
				<li><tt>01 00</tt> - assigned value for the curve "ffdhe2048"
				<li><tt>01 01</tt> - assigned value for the curve "ffdhe3072"
				<li><tt>01 02</tt> - assigned value for the curve "ffdhe4096"
				<li><tt>01 03</tt> - assigned value for the curve "ffdhe6144"
				<li><tt>01 04</tt> - assigned value for the curve "ffdhe8192"
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Extension - Session Ticket</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			The client indicates it has no session ticket
			to provide for this connection.
			<ul>
			<li><tt>00 23</tt> - assigned value for extension "Session Ticket"
			<li><tt>%2 %3</tt> - %nn2 bytes of "Session Ticket" extension data follows
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Extension - Encrypt-Then-MAC</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			The client indicates it can support EtM, which prevents
			<a href="https://iacr.org/archive/crypto2001/21390309.pdf"
			>certain vulnerabilities</a> in earlier versions of TLS.  In
			TLS 1.3 this mechanism is always used, so this extension
			will have no effect in this session.
			<ul>
				<li><tt>00 16</tt> - assigned value for extension "Encrypt Then MAC"
				<li><tt>%2 %3</tt> - %nn2 bytes of "Session Ticket" extension data follows
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Extension - Extended Master Secret</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			The client indicates support for extra cryptographic operations
			which prevent vulnerabilities in earlier versions of TLS (see <a
			href="https://www.ietf.org/rfc/rfc7627.html">RFC 7627</a> for details).
			In TLS 1.3 the vulnerabilities are no longer present, so this extension
			will have no effect in this session.
			<ul>
				<li><tt>00 17</tt> - assigned value for extension "Extended Master Secret"
				<li><tt>%2 %3</tt> - %nn2 bytes of "Session Ticket" extension data follows
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Extension - Signature Algorithms</span>
		<span class="bytes">
%next 34
%bytes
		</span>
		<div class="explanation">
			This extension indicates which signature
			algorithms the client supports.  This can
			influence the certificate that the server
			presents to the client, as well as the
			signature that is sent by the server in
			the CertificateVerify record.
			<br/><br/>
			This list is presented in descending order
			of the client's preference.
			<ul>
				<li><tt>00 0d</tt> - assigned value for extension "Signature Algorithms"
				<li><tt>%2 %3</tt> - %nn2 bytes of "Signature Algorithms" extension data follows
				<li><tt>%4 %5</tt> - %nn4 bytes of data are in the following list of algorithms
				<li><tt>04 03</tt> - assigned value for ECDSA-SECP256r1-SHA256
				<li><tt>05 03</tt> - assigned value for ECDSA-SECP384r1-SHA384
				<li><tt>06 03</tt> - assigned value for ECDSA-SECP521r1-SHA512
				<li><tt>08 07</tt> - assigned value for ED25519
				<li><tt>08 08</tt> - assigned value for ED448
				<li><tt>08 09</tt> - assigned value for RSA-PSS-PSS-SHA256
				<li><tt>08 0a</tt> - assigned value for RSA-PSS-PSS-SHA384
				<li><tt>08 0b</tt> - assigned value for RSA-PSS-PSS-SHA512
				<li><tt>08 04</tt> - assigned value for RSA-PSS-RSAE-SHA256
				<li><tt>08 05</tt> - assigned value for RSA-PSS-RSAE-SHA384
				<li><tt>08 06</tt> - assigned value for RSA-PSS-RSAE-SHA512
				<li><tt>04 01</tt> - assigned value for RSA-PKCS1-SHA256
				<li><tt>05 01</tt> - assigned value for RSA-PKCS1-SHA384
				<li><tt>06 01</tt> - assigned value for RSA-PKCS1-SHA512
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Extension - Supported Versions</span>
		<span class="bytes">
%next 7
%bytes
		</span>
		<div class="explanation">
			The client indicates its support of TLS 1.3. This is the only indication in the
			Client Hello record that hints the client supports TLS 1.3, since
			for compatibility reasons it has otherwise pretended to be a TLS 1.2 connection
			attempt.
			<ul>
				<li><tt>00 2b</tt> - assigned value for extension "Supported Versions"
				<li><tt>%2 %3</tt> - %nn2 bytes of "Supported Versions" extension data follows
				<li><tt>%4</tt> - %n4 bytes of TLS versions follow
				<li><tt>03 04</tt> - assigned value for TLS 1.3
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Extension - PSK Key Exchange Modes</span>
		<span class="bytes">
%next 6
%bytes
		</span>
		<div class="explanation">
			The client indicates the modes available
			for establishing keys from pre-shared keys
			(PSKs).  Since we do not use PSKs in this
			session, this extension has no effect.
			<ul>
				<li><tt>00 2d</tt> - assigned value for extension "PSK Key Exchange Modes"
				<li><tt>%2 %3</tt> - %nn2 bytes of "PSK Key Exchange Modes" extension data follows
				<li><tt>%4</tt> - %n4 bytes of exchange modes follow
				<li><tt>01</tt> - assigned value for "PSK with (EC)DHE key establishment"
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Extension - Key Share</span>
		<span class="bytes">
%next 42
%bytes
		</span>
		<div class="explanation">
			The client sends one or more ephemeral public keys
			using algorithm(s) that it thinks the server
			will support.  This allows the
			rest of the handshake after the ClientHello
			and ServerHello messages to be encrypted,
			unlike previous protocol versions where the
			handshake was sent in the clear.
			<ul>
				<li><tt>00 33</tt> - assigned value for extension "Key Share"
				<li><tt>%2 %3</tt> - %nn2 bytes of "Key Share" extension data follows
				<li><tt>%4 %5</tt> - %nn4 bytes of key share data follows
				<li><tt>00 1d</tt> - assigned value for x25519 (key exchange via curve25519)
				<li><tt>%8 %9</tt> - %nn8 bytes of public key follows
				<li><tt>%10 %11 ... %-2 %-1</tt></l> - public key from the step "Client Key Exchange Generation"
			</ul>
		</div>
	</span>

</span>
</div>
</div>
%empty

<div class="rec-outer">
<div class="calculation server">
<div class="rec-label">Server Key Exchange Generation</div>
<img class="illustration" src="images/key4.png" width="106" height="250"/>
<div class="rec-explanation">
	<p>The server calculates a private/public keypair
	for key exchange.  Key exchange is a technique
	where two parties can agree on the same number without
	an eavesdropper being able to tell what the number is.
	<p>
	It will do this via an elliptical curve method, using the x25519 curve.
	<p>
	Explaining and understanding the details of ECDHE key exchange
	is outside the scope of this document. I found Andrea Corbellini's
	<a href="https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">
	Elliptic Curve Cryptography: a gentle introduction</a> a good resource for this.
	<p>
	The private key is chosen by selecting an integer between
	0 and 2<sup>256</sup>-1.  It does this by generating 32
	bytes (256 bits) of random data.  The
	<a href="files/server-ephemeral-private.key" download="server-ephemeral-private.key">private key</a>
	selected is:

<pre class="ind2"><tt class="longboi"
>909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeaf</tt></pre>

	The <a href="files/server-ephemeral-public.key" download="server-ephemeral-public.key">public key</a>
	is chosen by "adding" the point represented by x=9 on the x25519 curve
	to itself "private key" number of times (you don't need to understand this).
	The public key calculated is:

<pre class="ind2"><tt class="longboi"
>9fd7ad6dcff4298dd3f96d5b1b2af910a0535b1488d7f8fabb349a982880b615</tt></pre>

	The public key calculation can be confirmed with command line tools:
	<codesample>
<pre><code>### requires openssl 1.1.0 or higher
$ openssl pkey -noout -text &lt; server-ephemeral-private.key

X25519 Private-Key:
priv:
    90:91:92:93:94:95:96:97:98:99:9a:9b:9c:9d:9e:
    9f:a0:a1:a2:a3:a4:a5:a6:a7:a8:a9:aa:ab:ac:ad:
    ae:af
pub:
    9f:d7:ad:6d:cf:f4:29:8d:d3:f9:6d:5b:1b:2a:f9:
    10:a0:53:5b:14:88:d7:f8:fa:bb:34:9a:98:28:80:
    b6:15
</code></pre>
	</codesample>
</div>
</div>
</div>
%empty

<div class="rec-outer">
<div class="record server">
<div class="rec-label">Server Hello</div>
<img class="illustration" src="images/key2.png" width="124" height="250"/>
<div class="rec-explanation">
	The server says "Hello" back.  The server provides information including the following:
	<ul>
	<li>server random data (used later in the handshake)
	<li>a selected cipher suite
	<li>a public key for key exchange
	<li>the negotiated protocol version
	</ul>
</div>
%file ../captures/caps/serverhello
<span class="record-data">
	<span class="string">
		<span class="label">Record Header</span>
		<span class="bytes">
%next 5
%bytes
		</span>
		<div class="explanation">
			TLS sessions are broken into the sending
			and receiving of "records", which are blocks
			of data with a type, a protocol version,
			and a length.
			<ul>
			<li><tt>%0</tt> - type is 0x16 (handshake record)
			<li><tt>%1 %2</tt> - legacy protocol version of "3,3" (TLS 1.2)
			<li><tt>%3 %4</tt> - %nn3 bytes of handshake message follows
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Handshake Header</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<ul>
			<li><tt>02</tt> - handshake message type 0x02 (server hello)
			<li><tt>%1 %2 %3</tt> - %nnn1 bytes of server hello data follows
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Server Version</span>
		<span class="bytes">
%next 2
%bytes
		</span>
		<div class="explanation">
			A protocol version of "3,3" (meaning TLS 1.2)
			is given.  Because middleboxes have been
			created and widely deployed that do not
			allow protocol versions that
			they do not recognize, the TLS 1.3 session
			must be disguised as a TLS 1.2 session.
			This field is no
			longer used for version negotiation and
			is hardcoded to the 1.2 version.  Instead
			version negotiation is performed using the
			"Supported Versions" extension below.
			<br/><br/>
			The unusual version number ("3,3" representing
			TLS 1.2) is due to TLS 1.0 being a minor
			revision of the SSL 3.0 protocol.  Therefore
			TLS 1.0 is represented by "3,1", TLS 1.1 is
			"3,2", and so on.
		</div>
	</span>

	<span class="string">
		<span class="label">Server Random</span>
		<span class="bytes">
%next 32
%bytes
		</span>
		<div class="explanation">
			The server provides 32 bytes of random data.  This data will be used later in the session.
			In this example we've made the random data a predictable string.
		</div>
	</span>

	<span class="string">
		<span class="label">Session ID</span>
		<span class="bytes">
%next 33
%bytes
		</span>
		<div class="explanation">
			This legacy field is no longer used to
			identify and re-use sessions.  Instead the
			server echos the session ID provided by the
			client, if any.
			<ul>
			<li><tt>%0</tt> - %n0 bytes of session ID follow
			<li><tt>%1 %2 ... %-2 %-1</tt> - session ID copied from Client Hello
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Cipher Suite</span>
		<span class="bytes">
%next 2
%bytes
		</span>
		<div class="explanation">
			The server has selected cipher suite 0x1302
			(TLS_AES_256_GCM_SHA384) from the list of options given by the client.
		</div>
	</span>

	<span class="string">
		<span class="label">Compression Method</span>
		<span class="bytes">
%next 1
%bytes
		</span>
		<div class="explanation">
			The server has selected compression method
			0x00 ("Null", which performs no compression)
			from the list of options given by the client.
		</div>
	</span>

	<span class="string">
		<span class="label">Extensions Length</span>
		<span class="bytes">
%next 2
%bytes
		</span>
		<div class="explanation">
			The server has returned a list of extensions
			to the client.  Because the server is
			forbidden from replying with an extension
			that the client did not send in its hello
			message, the server knows that the client
			will understand and support all extensions listed.
			<ul>
			<li><tt>%0 %1</tt> - the extensions will take %nn0 bytes of data
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Extension - Supported Versions</span>
		<span class="bytes">
%next 6
%bytes
		</span>
		<div class="explanation">
			The server indicates the negotiated TLS version of 1.3.
			<ul>
				<li><tt>00 2b</tt> - assigned value for extension "Supported Versions"
				<li><tt>%2 %3</tt> - %nn2 bytes of "Supported Versions" extension data follows
				<li><tt>03 04</tt> - assigned value for TLS 1.3
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Extension - Key Share</span>
		<span class="bytes">
%next 40
%bytes
		</span>
		<div class="explanation">
			The server sends a public key using the algorithm
			of the public key sent by the client.  Once this is sent
			encryption keys can be calculated and the rest of the
			handshake will be encrypted,
			unlike previous protocol versions where the
			handshake was sent in the clear.
			<ul>
				<li><tt>00 33</tt> - assigned value for extension "Key Share"
				<li><tt>%2 %3</tt> - %nn2 bytes of "Key Share" extension data follows
				<li><tt>00 1d</tt> - assigned value for x25519 (key exchange via curve25519)
				<li><tt>%6 %7</tt> - %nn6 bytes of public key follows
				<li><tt>%8 %9 ... %-2 %-1</tt></l> - public key from the step "Server Key Exchange Generation"
			</ul>
		</div>
	</span>
</span>
</div>
</div>
%empty

<div class="rec-outer">
<div class="calculation server">
<div class="rec-label">Server Handshake Keys Calc</div>
<img class="illustration" src="images/key9.png" width="97" height="250"/>
<div class="rec-explanation">
	The server now has the information to calculate the
	keys used to encrypt the rest of the handshake.  It uses the following
	information in this calculation:
	<ul>
	<li><a href="files/client-ephemeral-public.key">client public key</a> (from Client Hello)
	<li><a href="files/server-ephemeral-private.key">server private key</a> (from Server Key Exchange Generation)
	<li>SHA384 hash of ClientHello and ServerHello</li>
	</ul>
	First, the server finds the shared secret, which is the
	result of the key exchange that allows the client and server
	to agree on a number.  The server multiplies the client's
	public key with the server's private key using the curve25519()
	algorithm.  The 32-byte result is found to be:
	<pre class="ind2"><tt class="longboi"
	>df4a291baa1eb7cfa6934b29b474baad2697e29f1f920dcc77c8a0a088447624</tt></pre>

	I've provided <a href="files/curve25519-mult.c" download="curve25519-mult.c">a tool</a>
	to perform this calculation:
	<codesample>
<pre><code>$ cc -o curve25519-mult curve25519-mult.c
$ ./curve25519-mult server-ephemeral-private.key \
                    client-ephemeral-public.key | hexdump

0000000 df 4a 29 1b aa 1e b7 cf a6 93 4b 29 b4 74 ba ad
0000010 26 97 e2 9f 1f 92 0d cc 77 c8 a0 a0 88 44 76 24
</code></pre>
	</codesample>

	We then calculate the SHA384 hash of all handshake messages
	to this point (ClientHello and ServerHello).  The hash does
	not include the 5-byte "record" headers.  This "hello_hash"
	is <tt class="longboi"
	>e05f64fcd082bdb0dce473adf669c2769f257a1c75a51b7887468b5e0e7a7de4f4d34555112077f16e079019d5a845bd</tt>:
	<codesample>
<pre><code>$ (tail -c +6 clienthello; tail -c +6 serverhello) | openssl sha384
e05f64fcd082bdb0dce473adf669c2769f257a1c75a51b7887468b5e0e7a7de4f4d34555112077f16e079019d5a845bd
</code></pre>
	</codesample>

	We then feed the hash and the shared secret into a set of
	key derivation operations, designed to ensure the integrity
	of the handshake process and to protect against known and
	possible attacks:

	<processblock>
<pre>early_secret = HKDF-Extract(salt: 00, key: 00...)
empty_hash = SHA384("")
derived_secret = HKDF-Expand-Label(key: early_secret, label: "derived", ctx: empty_hash, len: 48)
handshake_secret = HKDF-Extract(salt: derived_secret, key: shared_secret)
client_secret = HKDF-Expand-Label(key: handshake_secret, label: "c hs traffic", ctx: hello_hash, len: 48)
server_secret = HKDF-Expand-Label(key: handshake_secret, label: "s hs traffic", ctx: hello_hash, len: 48)
client_handshake_key = HKDF-Expand-Label(key: client_secret, label: "key", ctx: "", len: 32)
server_handshake_key = HKDF-Expand-Label(key: server_secret, label: "key", ctx: "", len: 32)
client_handshake_iv = HKDF-Expand-Label(key: client_secret, label: "iv", ctx: "", len: 12)
server_handshake_iv = HKDF-Expand-Label(key: server_secret, label: "iv", ctx: "", len: 12)
</pre>
	</processblock>

	This has introduced two new cryptographic methods:
	<ul>
	<li><tt>HKDF-Extract</tt> - given a salt and some bytes of key material
	create 384 bits (48 bytes) of new key material, with the
	input key material's entropy evenly distributed in the
	output.
	<li><tt>HKDF-Expand-Label</tt> - given the inputs of key
	material, label, and context data, create a new key of the
	requested length.
	</ul>

	I've created <a href="files/hkdf-384.sh" download="hkdf-384">an HKDF tool</a>
	to perform these operations on the command line.
	<codesample>
<pre><code>$ hello_hash=e05f64fcd082bdb0dce473adf669c2769f257a1c75a51b7887468b5e0e7a7de4f4d34555112077f16e079019d5a845bd
$ shared_secret=df4a291baa1eb7cfa6934b29b474baad2697e29f1f920dcc77c8a0a088447624
$ zero_key=000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
$ early_secret=$(./hkdf-384 extract 00 $zero_key)
$ empty_hash=$(openssl sha384 < /dev/null | sed -e 's/.* //')
$ derived_secret=$(./hkdf-384 expandlabel $early_secret "derived" $empty_hash 48)
$ handshake_secret=$(./hkdf-384 extract $derived_secret $shared_secret)
$ csecret=$(./hkdf-384 expandlabel $handshake_secret "c hs traffic" $hello_hash 48)
$ ssecret=$(./hkdf-384 expandlabel $handshake_secret "s hs traffic" $hello_hash 48)
$ client_handshake_key=$(./hkdf-384 expandlabel $csecret "key" "" 32)
$ server_handshake_key=$(./hkdf-384 expandlabel $ssecret "key" "" 32)
$ client_handshake_iv=$(./hkdf-384 expandlabel $csecret "iv" "" 12)
$ server_handshake_iv=$(./hkdf-384 expandlabel $ssecret "iv" "" 12)
$ echo hssec: $handshake_secret
$ echo ssec: $ssecret
$ echo csec: $csecret
$ echo skey: $server_handshake_key
$ echo siv: $server_handshake_iv
$ echo ckey: $client_handshake_key
$ echo civ: $client_handshake_iv

hssec: bdbbe8757494bef20de932598294ea65b5e6bf6dc5c02a960a2de2eaa9b07c929078d2caa0936231c38d1725f179d299
ssec: 23323da031634b241dd37d61032b62a4f450584d1f7f47983ba2f7cc0cdcc39a68f481f2b019f9403a3051908a5d1622
csec: db89d2d6df0e84fed74a2288f8fd4d0959f790ff23946cdf4c26d85e51bebd42ae184501972f8d30c4a3e4a3693d0ef0
skey: 9f13575ce3f8cfc1df64a77ceaffe89700b492ad31b4fab01c4792be1b266b7f
siv: 9563bc8b590f671f488d2da3
ckey: 1135b4826a9a70257e5a391ad93093dfd7c4214812f493b3e3daae1eb2b1ac69
civ: 4256d2e0e88babdd05eb2f27
</code></pre>
	</codesample>

	From this we get the following key data:
	<ul>
	<li>handshake secret: <tt class="longboi"
	>bdbbe8757494bef20de932598294ea65b5e6bf6dc5c02a960a2de2eaa9b07c929078d2caa0936231c38d1725f179d299</tt>
	<li>server handshake traffic secret: <tt class="longboi"
	>23323da031634b241dd37d61032b62a4f450584d1f7f47983ba2f7cc0cdcc39a68f481f2b019f9403a3051908a5d1622</tt>.
	<li>client handshake traffic secret: <tt class="longboi"
	>db89d2d6df0e84fed74a2288f8fd4d0959f790ff23946cdf4c26d85e51bebd42ae184501972f8d30c4a3e4a3693d0ef0</tt>.
	<li>server handshake key: <tt class="longboi"
	>9f13575ce3f8cfc1df64a77ceaffe89700b492ad31b4fab01c4792be1b266b7f</tt>
	<li>server handshake IV: <tt class="longboi"
	>9563bc8b590f671f488d2da3</tt>
	<li>client handshake key: <tt class="longboi"
	>1135b4826a9a70257e5a391ad93093dfd7c4214812f493b3e3daae1eb2b1ac69</tt>
	<li>client handshake IV: <tt class="longboi"
	>4256d2e0e88babdd05eb2f27</tt>
	</ul>
</div>
</div>
</div>

<div class="rec-outer">
<div class="calculation client">
<div class="rec-label">Client Handshake Keys Calc</div>
<img class="illustration" src="images/key8.png" width="97" height="250"/>
<div class="rec-explanation">
	The client now has the information to calculate the
	keys that used to encrypt the rest of the handshake.  It uses the following
	information in this calculation:
	<ul>
	<li><a href="files/server-ephemeral-public.key">server public key</a> (from Server Hello)
	<li><a href="files/client-ephemeral-private.key">client private key</a> (from Client Key Exchange Generation)
	<li>SHA384 hash of ClientHello and ServerHello</li>
	</ul>
	First, the client finds the shared secret, which is the
	result of the key exchange that allows the client and server
	to agree on a number.  The client multiplies the server's
	public key with the client's private key using the curve25519()
	algorithm. The properties of elliptical curve multiplication will
	cause this to result in the same number found by the server in its
	multiplication. The 32-byte result is found to be:
	<pre class="ind2"><tt class="longboi"
	>df4a291baa1eb7cfa6934b29b474baad2697e29f1f920dcc77c8a0a088447624</tt></pre>

	I've provided <a href="files/curve25519-mult.c" download="curve25519-mult.c">a tool</a>
	to perform this calculation:
	<codesample>
<pre><code>$ cc -o curve25519-mult curve25519-mult.c
$ ./curve25519-mult client-ephemeral-private.key \
                    server-ephemeral-public.key | hexdump

0000000 df 4a 29 1b aa 1e b7 cf a6 93 4b 29 b4 74 ba ad
0000010 26 97 e2 9f 1f 92 0d cc 77 c8 a0 a0 88 44 76 24
</code></pre>
	</codesample>
	Since the shared secret above is the same number calculated by the
	server in "Server Handshake Keys Calc", the rest of
	the calculation is identical and the same values are found:
	<ul>
	<li>server handshake key: <tt class="longboi"
	>9f13575ce3f8cfc1df64a77ceaffe89700b492ad31b4fab01c4792be1b266b7f</tt>
	<li>server handshake IV: <tt class="longboi"
	>9563bc8b590f671f488d2da3</tt>
	<li>client handshake key: <tt class="longboi"
	>1135b4826a9a70257e5a391ad93093dfd7c4214812f493b3e3daae1eb2b1ac69</tt>
	<li>client handshake IV: <tt class="longboi"
	>4256d2e0e88babdd05eb2f27</tt>
	</ul>
</div>
</div>
</div>

<div class="rec-outer">
<div class="record server">
<div class="rec-label">Server Change Cipher Spec</div>
<div class="rec-explanation">
	This record served a purpose in earlier versions on TLS but is no longer needed.
	In "middlebox compatibility mode" this record is sent to help disguise the session as
	a TLS 1.2 session.
</div>
%file ../captures/caps/serverccs
<span class="record-data">
	<span class="string">
		<span class="label">Record Header</span>
		<span class="bytes">
%next 6
%bytes
		</span>
		<div class="explanation">
			TLS sessions are broken into the sending
			and receiving of "records", which are blocks
			of data with a type, a protocol version,
			and a length.
			<ul>
			<li><tt>14</tt> - type is 0x14 (ChangeCipherSpec record)
			<li><tt>%1 %2</tt> - legacy protocol version of "3,3" (TLS 1.2)
			<li><tt>%3 %4</tt> - the length of the record payload is %nn3 bytes
			<li><tt>%5</tt> - the payload of this message is defined as the byte 0x01
			</ul>
		</div>
	</span>
</span>
</div>
</div>
%empty

<div class="rec-outer">
<div class="record server">
<div class="rec-label">Wrapped Record</div>
<img class="illustration" src="images/key5.png" width="124" height="250"/>
<div class="rec-explanation">
	The connection (including the handshake) is encrypted from
	this point on.  The encryption of handshake data is new in
	TLS 1.3.
	<br/><br/>
	To reduce issues with middleboxes that block unrecognized
	TLS protocols, the encrypted handshake records are disguised as a
	TLS 1.2 session that has performed a successful session
	resume.
	<br/><br/>
	This wrapped record is discussed in its own section below this one.
</div>
%file ../captures/caps/serverencextensions
<span class="record-data">
	<span class="string">
		<span class="label">Record Header</span>
		<span class="bytes">
%next 5
%bytes
		</span>
		<div class="explanation">
			The TLS 1.3 records are encrypted into a
			TLS 1.2 record "wrapper" that looks like
			application data.
			<ul>
			<li><tt>%0</tt> - type is 0x17 (application data)
			<li><tt>%1 %2</tt> - legacy protocol version of "3,3" (TLS 1.2)
			<li><tt>%3 %4</tt> - %nn3 bytes of wrapped data follows
			</ul>
		</div>
	</span>

	<span class="string encrypted">
		<span class="label">Encrypted Data</span>
		<span class="bytes">
%next 7
%bytes
		</span>
		<div class="explanation">
			This data is encrypted with the server handshake key.
		</div>
	</span>
	<span class="string">
		<span class="label">Auth Tag</span>
		<span class="bytes">
%next 16
%bytes
		</span>
		<div class="explanation">
			This is the AEAD authentication tag
			that protects the integrity of the
			encrypted data and the record header.
		</div>
	</span>
%empty

	<div class="decryption">
		<div class="label">Decryption</div>
		<div class="explanation">
			This data is encrypted using the server
			handshake key and the server handshake IV that were
			generated during the "Server Handshake Keys
			Calc" step.  The IV will be modified
			by XOR'ing it by the count of records that
			have already been encrypted with this key,
			which in this case is 0.  The process also
			takes as input the 5-byte record header
			that this record begins with, as authenticated
			data that must match for the decryption to
			succeed.
			<br/><br/>
			Because the <tt>openssl</tt> command line
			tool does not yet support AEAD ciphers,
			I've written command line tools to both
			<a href="files/aes_256_gcm_decrypt.c" download="aes_256_gcm_decrypt.c">decrypt</a>
			and <a href="files/aes_256_gcm_encrypt.c" download="aes_256_gcm_encrypt.c">encrypt</a>
			this data.
			<codesample>
<pre><code>### from the "Server Handshake Keys Calc" step
$ key=9f13575ce3f8cfc1df64a77ceaffe89700b492ad31b4fab01c4792be1b266b7f
$ iv=9563bc8b590f671f488d2da3
### from this record
$ recdata=1703030017
$ authtag=9ddef56f2468b90adfa25101ab0344ae
$ recordnum=0
### may need to add -I and -L flags for include and lib dirs
$ cc -o aes_256_gcm_decrypt aes_256_gcm_decrypt.c -lssl -lcrypto
$ echo "6b e0 2f 9d a7 c2 dc" | xxd -r -p > /tmp/msg1
$ cat /tmp/msg1 \
  | ./aes_256_gcm_decrypt $iv $recordnum $key $recdata $authtag \
  | hexdump -C

00000000  08 00 00 02 00 00 16                              |.......|
</code></pre>
			</codesample>
		</div>
	</div>

%file ../captures/caps/serverextensions
	<span class="string decrypted">
		<span class="label">Encrypted Extensions</span>
		<span class="bytes">
%next 6
%bytes
		</span>
		<div class="explanation">
			This handshake message is represented in its own section below.
		</div>
	</span>

	<span class="string decrypted">
		<span class="label">Record Type</span>
		<span class="bytes">
%next 1
%bytes
		</span>
		<div class="explanation">
			Each TLS 1.3 record disguised as TLS 1.2
			application data has a final byte
			which indicates its actual record type.
			<ul>
			<li><tt>%0</tt> - type is 0x16 (handshake record)
			</ul>
		</div>
	</span>

%empty
</span>
</div>
</div>

<div class="rec-outer">
<div class="record server embedded">
<div class="rec-label">Server Encrypted Extensions</div>
<div class="rec-explanation">
	Any extensions that aren't needed for negotiating encryption
	keys should be listed here so they can be hidden from
	eavesdroppers and middleboxes.
</div>
%file ../captures/caps/serverextensions
<span class="record-data">
	<span class="string">
		<span class="label">Handshake Header</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<ul>
			<li><tt>%0</tt> - handshake message type 0x08 (encrypted extensions)
			<li><tt>%1 %2 %3</tt> - %nnn1 bytes of handshake message data follows
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Extensions</span>
		<span class="bytes">
%next 2
%bytes
		</span>
		<div class="explanation">
			<ul>
			<li><tt>%0 %1</tt> - %nn0 bytes of extension data follows
			</ul>
		</div>
	</span>
</span>
</div>
</div>
%next 1
%empty

<div class="rec-outer">
<div class="record server">
<div class="rec-label">Wrapped Record</div>
<img class="illustration" src="images/key5.png" width="124" height="250"/>
<div class="rec-explanation">
	The encryption of handshake data is new in TLS 1.3.
	<br/><br/>
	To reduce issues with middleboxes that block unrecognized
	TLS protocols, the encrypted handshake records are disguised as a
	TLS 1.2 session that has performed a successful session
	resume.
	<br/><br/>
	This wrapped record is discussed in its own section below this one.
</div>
%file ../captures/caps/serverenccert
<span class="record-data">
	<span class="string">
		<span class="label">Record Header</span>
		<span class="bytes">
%next 5
%bytes
		</span>
		<div class="explanation">
			The TLS 1.3 records are encrypted into a
			TLS 1.2 record "wrapper" that looks like
			application data.
			<ul>
			<li><tt>%0</tt> - type is 0x17 (application data)
			<li><tt>%1 %2</tt> - legacy protocol version of "3,3" (TLS 1.2)
			<li><tt>%3 %4</tt> - %nn3 bytes of wrapped data follows
			</ul>
		</div>
	</span>

	<span class="string encrypted">
		<span class="label">Encrypted Data</span>
		<span class="bytes">
%next 819
%bytes
		</span>
		<div class="explanation">
			This data is encrypted with the server handshake key.
		</div>
	</span>
	<span class="string">
		<span class="label">Auth Tag</span>
		<span class="bytes">
%next 16
%bytes
		</span>
		<div class="explanation">
			This is the AEAD authentication tag
			that protects the integrity of the
			encrypted data and the record header.
		</div>
	</span>
%empty

	<div class="decryption">
		<div class="label">Decryption</div>
		<div class="explanation">
			This data is encrypted using the server
			handshake key and the server handshake IV that were
			generated during the "Server Handshake Keys
			Calc" step.  The IV will be modified
			by XOR'ing it by the count of records that
			have already been encrypted with this key,
			which in this case is 1.  The process also
			takes as input the 5-byte record header
			that this record begins with, as authenticated
			data that must match for the decryption to
			succeed.
			<br/><br/>
			Because the <tt>openssl</tt> command line
			tool does not yet support AEAD ciphers,
			I've written command line tools to both
			<a href="files/aes_256_gcm_decrypt.c" download="aes_256_gcm_decrypt.c">decrypt</a>
			and <a href="files/aes_256_gcm_encrypt.c" download="aes_256_gcm_encrypt.c">encrypt</a>
			this data.
			<codesample>
<pre><code>### from the "Server Handshake Keys Calc" step
$ key=9f13575ce3f8cfc1df64a77ceaffe89700b492ad31b4fab01c4792be1b266b7f
$ iv=9563bc8b590f671f488d2da3
### from this record
$ recdata=1703030343
$ authtag=58faa5bafa30186c6b2f238eb530c73e
$ recordnum=1
### may need to add -I and -L flags for include and lib dirs
$ cc -o aes_256_gcm_decrypt aes_256_gcm_decrypt.c -lssl -lcrypto
$ echo "ba f0 0a 9b e5 0f 3f 23 07 e7 26 ed cb da cb e4 b1 86 16
  ... snip ...
  a9 19 a7 0e 3a 10 e3 08 41" | xxd -r -p > /tmp/msg1
$ cat /tmp/msg1 \
  | ./aes_256_gcm_decrypt $iv $recordnum $key $recdata $authtag \
  | hexdump -C

00000000  08 00 00 02 00 00 0b 00  03 2e 00 00 03 2a 00 03  |.............*..|
00000010  25 30 82 03 21 30 82 02  09 a0 03 02 01 02 02 08  |%0..!0..........|
00000020  15 5a 92 ad c2 04 8f 90  30 0d 06 09 2a 86 48 86  |.Z......0...*.H.|
00000000  0b 00 03 2e 00 00 03 2a  00 03 25 30 82 03 21 30  |.......*..%0..!0|
00000010  82 02 09 a0 03 02 01 02  02 08 15 5a 92 ad c2 04  |...........Z....|
00000020  8f 90 30 0d 06 09 2a 86  48 86 f7 0d 01 01 0b 05  |..0...*.H.......|
00000030  00 30 22 31 0b 30 09 06  03 55 04 06 13 02 55 53  |.0"1.0...U....US|
00000040  31 13 30 11 06 03 55 04  0a 13 0a 45 78 61 6d 70  |1.0...U....Examp|
... snip ...
</code></pre>
			</codesample>
		</div>
	</div>

%file ../captures/caps/servercert
	<span class="string decrypted">
		<span class="label">Server Certificate</span>
		<span class="bytes">
%next 818
%bytes
		</span>
		<div class="explanation">
			This handshake message is represented in its own section below.
		</div>
	</span>

	<span class="string decrypted">
		<span class="label">Record Type</span>
		<span class="bytes">
%next 1
%bytes
		</span>
		<div class="explanation">
			Each TLS 1.3 record disguised as TLS 1.2
			application data has a final byte
			which indicates its actual record type.
			<ul>
			<li><tt>%0</tt> - type is 0x16 (handshake record)
			</ul>
		</div>
	</span>

%empty
</span>
</div>
</div>

<div class="rec-outer">
<div class="record server embedded">
<div class="rec-label">Server Certificate</div>
<img class="illustration" src="images/key3.png" width="130" height="250"/>
<div class="rec-explanation">
	The server sends one or more certificates:
	<ul>
	<li>the certificate for this host, containing the hostname,
	a public key, and a signature from a third party asserting
	that the owner of the certificate's hostname holds the
	private key for this certificate
	<li>an optional list of further certificates, each of which signs
	the previous certificate, and which form a chain of trust
	leading from the host certificate to a trusted certificate
	that has been pre-installed on the client
	</ul>
	In an effort to keep this example small we only send a
	host certificate.  Certificates are in a binary format
	called DER <a href="certificate.html" target="_blank">which
	you can explore here</a>.

</div>
%file ../captures/caps/servercert
<span class="record-data">
	<span class="string">
		<span class="label">Handshake Header</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<ul>
			<li><tt>%0</tt> - handshake message type 0x0B (certificate)
			<li><tt>%1 %2 %3</tt> - %nnn1 bytes of certificate payload follow
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Request Context</span>
		<span class="bytes">
%next 1
%bytes
		</span>
		<div class="explanation">
			This record is empty because this certificate was not sent in
			response to a Certificate Request.
			<ul>
			<li><tt>%0</tt> - %n0 bytes of request context follows
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Certificates Length</span>
		<span class="bytes">
%next 3
%bytes
		</span>
		<div class="explanation">
			<ul>
			<li><tt>%0 %1 %2</tt> - %nnn0 bytes of certificates follow
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Certificate Length</span>
		<span class="bytes">
%next 3
%bytes
		</span>
		<div class="explanation">
			The length of the first (and only) certificate.
			<ul>
			<li><tt>%0 %1 %2</tt> - %nnn0 bytes of certificate follows
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Certificate</span>
		<span class="bytes">
%next 805
%bytes
		</span>
		<div class="explanation">
			The certificate is in ASN.1 DER
			encoding.  The details of this format and
			the content of this binary payload are
			documented <a href="certificate.html" target="_blank">on another page</a>.
			<a href="files/server.crt" download="server.crt">The certificate</a>
			can be converted to the binary data in this message
			at the command line:
			<codesample>
<pre><code>$ openssl x509 -outform der &lt; server.crt | hexdump

0000000 30 82 03 21 30 82 02 09 a0 03 02 01 02 02 08 15
0000010 5a 92 ad c2 04 8f 90 30 0d 06 09 2a 86 48 86 f7
... snip ...
</code></pre>
			</codesample>
		</div>
	</span>

	<span class="string">
		<span class="label">Certificate Extensions</span>
		<span class="bytes">
%next 2
%bytes
		</span>
		<div class="explanation">
			The server can provide extension data for the certificate.
			<ul>
			<li><tt>%0 %1</tt> - %nn0 bytes of extension data follows
			</ul>
		</div>
	</span>
</span>
</div>
</div>
%next 1
%empty

<div class="rec-outer">
<div class="record server">
<div class="rec-label">Wrapped Record</div>
<img class="illustration" src="images/key5.png" width="124" height="250"/>
<div class="rec-explanation">
	The encryption of handshake data is new in TLS 1.3.
	<br/><br/>
	To reduce issues with middleboxes that block unrecognized
	TLS protocols, the encrypted handshake records are disguised as a
	TLS 1.2 session that has performed a successful session
	resume.
	<br/><br/>
	This wrapped record is discussed in its own section below this one.
</div>
%file ../captures/caps/serverenccertverify
<span class="record-data">
	<span class="string">
		<span class="label">Record Header</span>
		<span class="bytes">
%next 5
%bytes
		</span>
		<div class="explanation">
			The TLS 1.3 records are encrypted into a
			TLS 1.2 record "wrapper" that looks like
			application data.
			<ul>
			<li><tt>%0</tt> - type is 0x17 (application data)
			<li><tt>%1 %2</tt> - legacy protocol version of "3,3" (TLS 1.2)
			<li><tt>%3 %4</tt> - %nn3 bytes of wrapped data follows
			</ul>
		</div>
	</span>

	<span class="string encrypted">
		<span class="label">Encrypted Data</span>
		<span class="bytes">
%next 265
%bytes
		</span>
		<div class="explanation">
			This data is encrypted with the server handshake key.
		</div>
	</span>
	<span class="string">
		<span class="label">Auth Tag</span>
		<span class="bytes">
%next 16
%bytes
		</span>
		<div class="explanation">
			This is the AEAD authentication tag
			that protects the integrity of the
			encrypted data and the record header.
		</div>
	</span>
%empty

	<div class="decryption">
		<div class="label">Decryption</div>
		<div class="explanation">
			This data is encrypted using the server
			handshake key and the server handshake IV that were
			generated during the "Server Handshake Keys
			Calc" step.  The IV will be modified
			by XOR'ing it by the count of records that
			have already been encrypted with this key,
			which in this case is 2.  The process also
			takes as input the 5-byte record header
			that this record begins with, as authenticated
			data that must match for the decryption to
			succeed.
			<br/><br/>
			Because the <tt>openssl</tt> command line
			tool does not yet support AEAD ciphers,
			I've written command line tools to both
			<a href="files/aes_256_gcm_decrypt.c" download="aes_256_gcm_decrypt.c">decrypt</a>
			and <a href="files/aes_256_gcm_encrypt.c" download="aes_256_gcm_encrypt.c">encrypt</a>
			this data.
			<codesample>
<pre><code>### from the "Server Handshake Keys Calc" step
$ key=9f13575ce3f8cfc1df64a77ceaffe89700b492ad31b4fab01c4792be1b266b7f
$ iv=9563bc8b590f671f488d2da3
### from this record
$ recdata=1703030119
$ authtag=96a3232367ff075e1c66dd9cbedc4713
$ recordnum=2
### may need to add -I and -L flags for include and lib dirs
$ cc -o aes_256_gcm_decrypt aes_256_gcm_decrypt.c -lssl -lcrypto
$ echo "73 71 9f ce 07 ec 2f 6d 3b ba 02 92 a0 d4 0b 27 70 c0 6a 27
  ... snip ...
  d9 8d a8 8e bb 6e a8 0a 3a 11 f0 0e a2" | xxd -r -p > /tmp/msg1
$ cat /tmp/msg1 \
  | ./aes_256_gcm_decrypt $iv $recordnum $key $recdata $authtag \
  | hexdump -C

00000000  0f 00 01 04 08 04 01 00  5c bb 24 c0 40 93 32 da  |........\.$.@.2.|
00000010  a9 20 bb ab bd b9 bd 50  17 0b e4 9c fb e0 a4 10  |. .....P........|
00000020  7f ca 6f fb 10 68 e6 5f  96 9e 6d e7 d4 f9 e5 60  |..o..h._..m....`|
... snip ...
</code></pre>
			</codesample>
		</div>
	</div>

%file ../captures/caps/servercertverify
	<span class="string decrypted">
		<span class="label">Server Certificate Verify</span>
		<span class="bytes">
%next 264
%bytes
		</span>
		<div class="explanation">
			This handshake message is represented in its own section below.
		</div>
	</span>

	<span class="string decrypted">
		<span class="label">Record Type</span>
		<span class="bytes">
%next 1
%bytes
		</span>
		<div class="explanation">
			Each TLS 1.3 record disguised as TLS 1.2
			application data has a final byte
			which indicates its actual record type.
			<ul>
			<li><tt>%0</tt> - type is 0x16 (handshake record)
			</ul>
		</div>
	</span>

%empty
</span>
</div>
</div>

<div class="rec-outer">
<div class="record server embedded">
<div class="rec-label">Server Certificate Verify</div>
<div class="rec-explanation">
	The server provides information that ties the public key
	generated during Server Key Exchange Generation to the
	ownership of the certificate's private key.
</div>
%file ../captures/caps/servercertverify
<span class="record-data">
	<span class="string">
		<span class="label">Handshake Header</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<ul>
			<li><tt>%0</tt> - handshake message type 0x0f (certificate verify)
			<li><tt>%1 %2 %3</tt> - %nnn1 bytes of handshake message data follows
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Signature</span>
		<span class="bytes">
%next 260
%bytes
		</span>
		<div class="explanation">
			Because the server is generating ephemeral
			keys for each session (optional in TLS 1.2,
			mandatory in TLS 1.3) the session is not
			inherently tied to the certificate as it
			was in previous versions of TLS, when the
			certificate's public/private key were used
			for key exchange.
			<br/><br/>
			To prove
			that the server owns the server certificate
			(giving the certificate validity in this
			TLS session), it signs a hash of the handshake
			messages using the certificate's private
			key.  The signature can be proven valid by
			the client by using the certificate's public
			key.
			<ul>
			<li><tt>08 04</tt> - reserved value for RSA-PSS-RSAE-SHA256 signature
			<li><tt>%2 %3</tt> - %nn2 bytes of signature data follows
			<li><tt>%4 %5 %6 ... %-3 %-2 %-1</tt> - a signature over this handshake's hash
			</ul>
			The signing process can't be reproduced byte-for-byte
			at the command line because the signing tool introduces
			random or changing data into the signature.
			<br/><br/>
			We can verify the signature using the
			<a href="files/server.crt" download="server.crt">server's certificate</a>
			at the command line:
			<codesample>
<pre><code>### find the hash of the conversation to this point, excluding
### 5-byte record headers or 1-byte wrapped record trailers
$ handshake_hash=$((
   tail -c +6 clienthello;
   tail -c +6 serverhello;
   perl -pe 's/.$// if eof' serverextensions;
   perl -pe 's/.$// if eof' servercert) | openssl sha384)

### build the data that was signed:
### 1. add 64 space characters
$ echo -n '                                ' > /tmp/tosign
$ echo -n '                                ' >> /tmp/tosign
### 2. add this fixed string
$ echo -n 'TLS 1.3, server CertificateVerify' >> /tmp/tosign
### 3. add a single null character
$ echo -en '\0' >> /tmp/tosign
### 4. add hash of handshake to this point
$ echo $handshake_hash | xxd -r -p >> /tmp/tosign

### copy the signature that we want to verify
$ echo "5c bb 24 c0 40 93 32 da a9 20 bb ab bd b9 bd 50 17 0b e4 9c
  fb e0 a4 10 7f ca 6f fb 10 68 e6 5f 96 9e 6d e7 d4 f9 e5 60 38 d6
  7c 69 c0 31 40 3a 7a 7c 0b cc 86 83 e6 57 21 a0 c7 2c c6 63 40 19
  ad 1d 3a d2 65 a8 12 61 5b a3 63 80 37 20 84 f5 da ec 7e 63 d3 f4
  93 3f 27 22 74 19 a6 11 03 46 44 dc db c7 be 3e 74 ff ac 47 3f aa
  ad de 8c 2f c6 5f 32 65 77 3e 7e 62 de 33 86 1f a7 05 d1 9c 50 6e
  89 6c 8d 82 f5 bc f3 5f ec e2 59 b7 15 38 11 5e 9c 8c fb a6 2e 49
  bb 84 74 f5 85 87 b1 1b 8a e3 17 c6 33 e9 c7 6c 79 1d 46 62 84 ad
  9c 4f f7 35 a6 d2 e9 63 b5 9b bc a4 40 a3 07 09 1a 1b 4e 46 bc c7
  a2 f9 fb 2f 1c 89 8e cb 19 91 8b e4 12 1d 7e 8e d0 4c d5 0c 9a 59
  e9 87 98 01 07 bb bf 29 9c 23 2e 7f db e1 0a 4c fd ae 5c 89 1c 96
  af df f9 4b 54 cc d2 bc 19 d3 cd aa 66 44 85 9c" | xxd -r -p > /tmp/sig

### extract the public key from the certificate
$ openssl x509 -pubkey -noout -in server.crt > server.pub

### verify the signature
$ cat /tmp/tosign | openssl dgst -verify server.pub -sha256 \
    -sigopt rsa_padding_mode:pss -sigopt rsa_pss_saltlen:-1 -signature /tmp/sig

Verified OK
</code></pre>
			</codesample>
		</div>
	</span>
</span>
</div>
</div>
%next 1
%empty


<div class="rec-outer">
<div class="record server">
<div class="rec-label">Wrapped Record</div>
<img class="illustration" src="images/key5.png" width="124" height="250"/>
<div class="rec-explanation">
	The encryption of handshake data is new in TLS 1.3.
	<br/><br/>
	To reduce issues with middleboxes that block unrecognized
	TLS protocols, the encrypted handshake records are disguised as a
	TLS 1.2 session that has performed a successful session
	resume.
	<br/><br/>
	This wrapped record is discussed in its own section below this one.
</div>
%file ../captures/caps/serverencfinished
<span class="record-data">
	<span class="string">
		<span class="label">Record Header</span>
		<span class="bytes">
%next 5
%bytes
		</span>
		<div class="explanation">
			The TLS 1.3 records are encrypted into a
			TLS 1.2 record "wrapper" that looks like
			application data.
			<ul>
			<li><tt>%0</tt> - type is 0x17 (application data)
			<li><tt>%1 %2</tt> - legacy protocol version of "3,3" (TLS 1.2)
			<li><tt>%3 %4</tt> - %nn3 bytes of wrapped data follows
			</ul>
		</div>
	</span>

	<span class="string encrypted">
		<span class="label">Encrypted Data</span>
		<span class="bytes">
%next 53
%bytes
		</span>
		<div class="explanation">
			This data is encrypted with the server handshake key.
		</div>
	</span>
	<span class="string">
		<span class="label">Auth Tag</span>
		<span class="bytes">
%next 16
%bytes
		</span>
		<div class="explanation">
			This is the AEAD authentication tag
			that protects the integrity of the
			encrypted data and the record header.
		</div>
	</span>
%empty

	<div class="decryption">
		<div class="label">Decryption</div>
		<div class="explanation">
			This data is encrypted using the server
			handshake key and the server handshake IV that were
			generated during the "Server Handshake Keys
			Calc" step.  The IV will be modified
			by XOR'ing it by the count of records that
			have already been encrypted with this key,
			which in this case is 3.  The process also
			takes as input the 5-byte record header
			that this record begins with, as authenticated
			data that must match for the decryption to
			succeed.
			<br/><br/>
			Because the <tt>openssl</tt> command line
			tool does not yet support AEAD ciphers,
			I've written command line tools to both
			<a href="files/aes_256_gcm_decrypt.c" download="aes_256_gcm_decrypt.c">decrypt</a>
			and <a href="files/aes_256_gcm_encrypt.c" download="aes_256_gcm_encrypt.c">encrypt</a>
			this data.
			<codesample>
<pre><code>### from the "Server Handshake Keys Calc" step
$ key=9f13575ce3f8cfc1df64a77ceaffe89700b492ad31b4fab01c4792be1b266b7f
$ iv=9563bc8b590f671f488d2da3
### from this record
$ recdata=1703030045
$ authtag=078440c0742374744aecf28cf3182fd0
$ recordnum=3
### may need to add -I and -L flags for include and lib dirs
$ cc -o aes_256_gcm_decrypt aes_256_gcm_decrypt.c -lssl -lcrypto
$ echo "10 61 de 27 e5 1c 2c 9f 34 29 11 80 6f 28 2b 71 0c 10 63 2c a5 00 67 55 88 0d bf 70 06 00 2d 0e 84 fe d9 ad f2 7a 43 b5 19
  23 03 e4 df 5c 28 5d 58 e3 c7 62 24" | xxd -r -p > /tmp/msg1
$ cat /tmp/msg1 \
  | ./aes_256_gcm_decrypt $iv $recordnum $key $recdata $authtag \
  | hexdump -C

00000000  14 00 00 30 7e 30 ee cc  b6 b2 3b e6 c6 ca 36 39  |...0~0....;...69|
00000010  92 e8 42 da 87 7e e6 47  15 ae 7f c0 cf 87 f9 e5  |..B..~.G........|
00000020  03 21 82 b5 bb 48 d1 e3  3f 99 79 05 5a 16 0c 8d  |.!...H..?.y.Z...|
00000030  bb b1 56 9c 16                                    |..V..|
</code></pre>
			</codesample>
		</div>
	</div>

%file ../captures/caps/serverfinished
	<span class="string decrypted">
		<span class="label">Server Finished</span>
		<span class="bytes">
%next 52
%bytes
		</span>
		<div class="explanation">
			This handshake message is represented in its own section below.
		</div>
	</span>

	<span class="string decrypted">
		<span class="label">Record Type</span>
		<span class="bytes">
%next 1
%bytes
		</span>
		<div class="explanation">
			Each TLS 1.3 record disguised as TLS 1.2
			application data has a final byte
			which indicates its actual record type.
			<ul>
			<li><tt>%0</tt> - type is 0x16 (handshake record)
			</ul>
		</div>
	</span>
</span>
</div>
</div>
%empty


<div class="rec-outer">
<div class="record server embedded">
<div class="rec-label">Server Handshake Finished</div>
<div class="rec-explanation">
	To verify that the handshake was successful and not tampered
	with, the server calculates verification data that client will agree on.
	The verification data is built from a hash of all handshake
	messages.
</div>
%file ../captures/caps/serverfinished
<span class="record-data">
	<span class="string">
		<span class="label">Handshake Header</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<ul>
			<li><tt>%0</tt> - handshake message type 0x14 (finished)
			<li><tt>%1 %2 %3</tt> - %nnn1 bytes of handshake finished data follows
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Verify Data</span>
		<span class="bytes">
%next 48
%bytes
		</span>
		<div class="explanation">
			The verify_data is built using the
			server_secret from
			the "Server Handshake Keys Calc" step and
			a SHA384 hash of every handshake record
			before this point (Client Hello to Server Certificate
			Verify).

			<processblock class="notrunc">
<pre>finished_key = HKDF-Expand-Label(key: server_secret, label: "finished", ctx: "", len: 32)
finished_hash = SHA384(Client Hello ... Server Cert Verify)
verify_data = HMAC-SHA384(key: finished_key, msg: finished_hash)
</pre>
			</processblock>

			We can use <a href="files/hkdf-384.sh" download="hkdf-384">the HKDF
			tool</a> to reproduce this on the command line.
			<codesample>
<pre><code>### find the hash of the conversation to this point, excluding
### 5-byte record headers or 1-byte wrapped record trailers
$ fin_hash=$((
    tail -c +6 clienthello;
    tail -c +6 serverhello;
    perl -pe 's/.$// if eof' serverextensions;
    perl -pe 's/.$// if eof' servercert;
    perl -pe 's/.$// if eof' servercertverify) | openssl sha384)
$ sht_secret=23323da031634b241dd37d61032b62a4f450584d1f7f47983ba2f7cc0cdcc39a68f481f2b019f9403a3051908a5d1622
$ fin_key=$(./hkdf-384 expandlabel $sht_secret "finished" "" 48)
$ echo $fin_hash | xxd -r -p \
    | openssl dgst -sha384 -mac HMAC -macopt hexkey:$fin_key

7e30eeccb6b23be6c6ca363992e842da877ee64715ae7fc0cf87f9e5032182b5bb48d1e33f9979055a160c8dbbb1569c
</code></pre>
			</codesample>
		</div>
	</span>
</div>
</div>
%next 1
%empty

<div class="rec-outer">
<div class="calculation server">
<div class="rec-label">Server Application Keys Calc</div>
<img class="illustration" src="images/key9.png" width="97" height="250"/>
<div class="rec-explanation">
	The server now has the information to calculate the
	keys used to encrypt application traffic.
	It uses the following information in this calculation:
	<ul>
	<li>The handshake secret (from "Server Handshake Key Calc")
	<li>The SHA384 hash of every handshake message from Client Hello to Server Handshake Finished</li>
	</ul>
	We calculate the SHA384 hash of all handshake messages to
	this point(Client Hello, Server Hello, [unwrapped] Encrypted Extensions,
	[unwrapped] Server Certificate, [unwrapped] Server Certificate Verify,
	[unwrapped] Server Finished).  The hash input does not include the 5-byte
	"record" headers of ClientHello and ServerHello.  It also
	doesn't include the trailing 1-byte "record type" of unwrapped records.

	This "handshake_hash" is <tt class="longboi"
	>fa6800169a6baac19159524fa7b9721b41be3c9db6f3f93fa5ff7e3db3ece204d2b456c51046e40ec5312c55a86126f5</tt>:
	<codesample>
	<pre><code># strip first 5 bytes of hello records, and trailing byte of unwrapped records
$ (tail -c +6 clienthello; tail -c +6 serverhello; \
   perl -pe 's/.$// if eof' serverextensions; \
   perl -pe 's/.$// if eof' servercert; \
   perl -pe 's/.$// if eof' servercertverify; \
   perl -pe 's/.$// if eof' serverfinished) | openssl sha384

fa6800169a6baac19159524fa7b9721b41be3c9db6f3f93fa5ff7e3db3ece204d2b456c51046e40ec5312c55a86126f5
	</code></pre>
	</codesample>

	We then feed the hash and the handshake secret into a set of
	key derivation operations, designed to ensure the integrity
	of the handshake process and to protect against known and
	possible attacks:

	<processblock>
<pre>empty_hash = SHA384("")
derived_secret = HKDF-Expand-Label(key: handshake_secret, label: "derived", ctx: empty_hash, len: 48)
master_secret = HKDF-Extract(salt: derived_secret, key: 00...)
client_secret = HKDF-Expand-Label(key: master_secret, label: "c ap traffic", ctx: handshake_hash, len: 48)
server_secret = HKDF-Expand-Label(key: master_secret, label: "s ap traffic", ctx: handshake_hash, len: 48)
client_application_key = HKDF-Expand-Label(key: client_secret, label: "key", ctx: "", len: 32)
server_application_key = HKDF-Expand-Label(key: server_secret, label: "key", ctx: "", len: 32)
client_application_iv = HKDF-Expand-Label(key: client_secret, label: "iv", ctx: "", len: 12)
server_application_iv = HKDF-Expand-Label(key: server_secret, label: "iv", ctx: "", len: 12)
</pre>
	</processblock>

	I've created <a href="files/hkdf-384.sh" download="hkdf-384">an HKDF tool</a>
	to perform these operations on the command line.
	<codesample>
<pre><code>$ handshake_hash=fa6800169a6baac19159524fa7b9721b41be3c9db6f3f93fa5ff7e3db3ece204d2b456c51046e40ec5312c55a86126f5
$ handshake_secret=bdbbe8757494bef20de932598294ea65b5e6bf6dc5c02a960a2de2eaa9b07c929078d2caa0936231c38d1725f179d299
$ zero_key=000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
$ empty_hash=$(openssl sha384 < /dev/null | sed -e 's/.* //')
$ derived_secret=$(./hkdf-384 expandlabel $handshake_secret "derived" $empty_hash 48)
$ master_secret=$(./hkdf-384 extract $derived_secret $zero_key)
$ csecret=$(./hkdf-384 expandlabel $master_secret "c ap traffic" $handshake_hash 48)
$ ssecret=$(./hkdf-384 expandlabel $master_secret "s ap traffic" $handshake_hash 48)
$ client_application_key=$(./hkdf-384 expandlabel $csecret "key" "" 32)
$ server_application_key=$(./hkdf-384 expandlabel $ssecret "key" "" 32)
$ client_application_iv=$(./hkdf-384 expandlabel $csecret "iv" "" 12)
$ server_application_iv=$(./hkdf-384 expandlabel $ssecret "iv" "" 12)
$ echo skey: $server_application_key
$ echo siv: $server_application_iv
$ echo ckey: $client_application_key
$ echo civ: $client_application_iv

skey: 01f78623f17e3edcc09e944027ba3218d57c8e0db93cd3ac419309274700ac27
siv: 196a750b0c5049c0cc51a541
ckey: de2f4c7672723a692319873e5c227606691a32d1c59d8b9f51dbb9352e9ca9cc
civ: bb007956f474b25de902432f
</code></pre>
	</codesample>

	From this we get the following key data:
	<ul>
	<li>server application key: <tt class="longboi"
	>01f78623f17e3edcc09e944027ba3218d57c8e0db93cd3ac419309274700ac27</tt>
	<li>server application IV: <tt class="longboi">196a750b0c5049c0cc51a541</tt>
	<li>client application key: <tt class="longboi"
	>de2f4c7672723a692319873e5c227606691a32d1c59d8b9f51dbb9352e9ca9cc</tt>
	<li>client application IV: <tt class="longboi">bb007956f474b25de902432f</tt>
	</ul>
</div>
</div>

<div class="rec-outer">
<div class="calculation client">
<div class="rec-label">Client Application Keys Calc</div>
<div class="rec-explanation">
	The client now has the information to calculate the
	keys used to encrypt application traffic.
	It performs the same calculation shown in "Server Application
	Keys Calc" and finds the same values:
	<ul>
	<li>server application key: <tt class="longboi"
	>01f78623f17e3edcc09e944027ba3218d57c8e0db93cd3ac419309274700ac27</tt>
	<li>server application IV: <tt class="longboi">196a750b0c5049c0cc51a541</tt>
	<li>client application key: <tt class="longboi"
	>de2f4c7672723a692319873e5c227606691a32d1c59d8b9f51dbb9352e9ca9cc</tt>
	<li>client application IV: <tt class="longboi">bb007956f474b25de902432f</tt>
	</ul>
</div>
</div>
</div>

<div class="rec-outer">
<div class="record client">
<div class="rec-label">Client Change Cipher Spec</div>
<div class="rec-explanation">
	This record served a purpose in earlier versions on TLS but is no longer needed.
	In "middlebox compatibility mode" this record is sent to help disguise the session as
	a TLS 1.2 session.
</div>
%file ../captures/caps/clientccs
<span class="record-data">
	<span class="string">
		<span class="label">Record Header</span>
		<span class="bytes">
%next 6
%bytes
		</span>
		<div class="explanation">
			TLS sessions are broken into the sending
			and receiving of "records", which are blocks
			of data with a type, a protocol version,
			and a length.
			<ul>
			<li><tt>14</tt> - type is 0x14 (ChangeCipherSpec record)
			<li><tt>%1 %2</tt> - legacy protocol version of "3,3" (TLS 1.2)
			<li><tt>%3 %4</tt> - the length of the record payload is %nn3 bytes
			<li><tt>%5</tt> - the payload of this message is defined as the byte 0x01
			</ul>
		</div>
	</span>
</span>
</div>
</div>
%empty

<div class="rec-outer">
<div class="record client">
<div class="rec-label">Wrapped Record</div>
<div class="rec-explanation">
	To reduce issues with middleboxes that block unrecognized
	TLS protocols, TLS 1.3 records are disguised as TLS 1.2
	application data records.
	<br/><br/>
	The wrapped record is discussed in its own section below this one.
</div>
%file ../captures/caps/clientencfinished
<span class="record-data">
	<span class="string">
		<span class="label">Record Header</span>
		<span class="bytes">
%next 5
%bytes
		</span>
		<div class="explanation">
			The TLS 1.3 record is encrypted into a TLS
			1.2 record "wrapper" that looks like
			application data.
			<ul>
			<li><tt>%0</tt> - type is 0x17 (application data)
			<li><tt>%1 %2</tt> - legacy protocol version of "3,3" (TLS 1.2)
			<li><tt>%3 %4</tt> - %nn3 bytes of wrapped data follows
			</ul>
		</div>
	</span>

	<span class="string encrypted">
		<span class="label">Encrypted Data</span>
		<span class="bytes">
%next 53
%bytes
		</span>
		<div class="explanation">
			This data is encrypted with the client handshake key.
		</div>
	</span>
	<span class="string">
		<span class="label">Auth Tag</span>
		<span class="bytes">
%next 16
%bytes
		</span>
		<div class="explanation">
			This is the AEAD authentication tag
			that protects the integrity of the
			encrypted data and the record header.
		</div>
	</span>
%empty

%file ../captures/caps/clientfinished
	<div class="decryption">
		<div class="label">Decryption</div>
		<div class="explanation">
			This data is encrypted using the client
			handshake key and the client handshake IV that were
			generated during the "Client Handshake Keys
			Calc" step.  The IV will be modified
			by XOR'ing it by the count of records that
			have already been encrypted with this key,
			which in this case is 0.  The process also
			takes as input the 5-byte record header
			that this record begins with, as authenticated
			data that must match for the decryption to
			succeed.
			<br/><br/>
			Because the <tt>openssl</tt> command line
			tool does not yet support AEAD ciphers,
			I've written command line tools to both
			<a href="files/aes_256_gcm_decrypt.c" download="aes_256_gcm_decrypt.c">decrypt</a>
			and <a href="files/aes_256_gcm_encrypt.c" download="aes_256_gcm_encrypt.c">encrypt</a>
			this data.
			<codesample>
<pre><code>### from the "Client Handshake Keys Calc" step
$ key=1135b4826a9a70257e5a391ad93093dfd7c4214812f493b3e3daae1eb2b1ac69
$ iv=4256d2e0e88babdd05eb2f27
### from this record
$ recdata=1703030045
$ authtag=0a69a88d4bf635c85eb874aebc9dfde8
$ recordnum=0
### may need to add -I and -L flags for include and lib dirs
$ cc -o aes_256_gcm_decrypt aes_256_gcm_decrypt.c -lssl -lcrypto
$ echo "9f f9 b0 63 17 51 77 32 2a 46 dd 98 96 f3 c3 bb 82 0a b5
  17 43 eb c2 5f da dd 53 45 4b 73 de b5 4c c7 24 8d 41 1a 18 bc
  cf 65 7a 96 08 24 e9 a1 93 64 83 7c 35" | xxd -r -p > /tmp/msg2
$ cat /tmp/msg2 \
  | ./aes_256_gcm_decrypt $iv $recordnum $key $recdata $authtag \
  | hexdump -C

00000000  14 00 00 30 bf f5 6a 67  1b 6c 65 9d 0a 7c 5d d1  |...0..jg.le..|].|
00000010  84 28 f5 8b dd 38 b1 84  a3 ce 34 2d 9f de 95 cb  |.(...8....4-....|
00000020  d5 05 6f 7d a7 91 8e e3  20 ea b7 a9 3a bd 8f 1c  |..o}.... ...:...|
00000030  02 45 4d 27 16                                    |.EM'.|
</code></pre>
			</codesample>
		</div>
	</div>

	<span class="string decrypted">
		<span class="label">Client Handshake Finished</span>
		<span class="bytes">
%next 52
%bytes
		</span>
		<div class="explanation">
			This handshake message is represented in its own section below.
		</div>
	</span>

	<span class="string decrypted">
		<span class="label">Record Type</span>
		<span class="bytes">
%next 1
%bytes
		</span>
		<div class="explanation">
			Each TLS 1.3 record disguised as TLS 1.2
			application data has a final non-zero byte
			which indicates its actual record type.
			<ul>
			<li><tt>%0</tt> - type is 0x16 (handshake record)
			</ul>
		</div>
	</span>
</div>
</div>
%empty

<div class="rec-outer">
<div class="record client embedded">
<div class="rec-label">Client Handshake Finished</div>
<div class="rec-explanation">
	To verify that the handshake was successful and not tampered
	with, the client calculates verification data that the
	server will agree on, and encrypts it with the client
	handshake key.  The verification data is built from a hash
	of all handshake messages.
</div>
%file ../captures/caps/clientfinished
<span class="record-data">
	<span class="string">
		<span class="label">Handshake Header</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<ul>
			<li><tt>%0</tt> - handshake message type 0x14 (finished)
			<li><tt>%1 %2 %3</tt> - %nnn1 bytes of handshake finished data follow
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Verify Data</span>
		<span class="bytes">
%next 48
%bytes
		</span>
		<div class="explanation">
			The verify_data is built using the
			client_secret from
			the "Server Handshake Keys Calc" step and
			a SHA384 hash of every handshake record
			before this point (Client Hello to Server Finished).

			<processblock class="notrunc">
<pre>finished_key = HKDF-Expand-Label(key: client_secret, label: "finished", ctx: "", len: 32)
finished_hash = SHA384(Client Hello ... Server Finished)
verify_data = HMAC-SHA384(key: finished_key, msg: finished_hash)
</pre>
			</processblock>

			We can use <a href="files/hkdf-384.sh" download="hkdf-384">the HKDF
			tool</a> to reproduce this on the command line.
			<codesample>
<pre><code>### find the hash of the conversation to this point, excluding
### 5-byte record headers or 1-byte wrapped record trailers
$ fin_hash=$((
    tail -c +6 clienthello;
    tail -c +6 serverhello;
    perl -pe 's/.$// if eof' serverextensions;
    perl -pe 's/.$// if eof' servercert;
    perl -pe 's/.$// if eof' servercertverify;
    perl -pe 's/.$// if eof' serverfinished) | openssl sha384)
$ cht_secret=db89d2d6df0e84fed74a2288f8fd4d0959f790ff23946cdf4c26d85e51bebd42ae184501972f8d30c4a3e4a3693d0ef0
$ fin_key=$(./hkdf-384 expandlabel $cht_secret "finished" "" 48)
$ echo $fin_hash | xxd -r -p \
    | openssl dgst -sha384 -mac HMAC -macopt hexkey:$fin_key

bff56a671b6c659d0a7c5dd18428f58bdd38b184a3ce342d9fde95cbd5056f7da7918ee320eab7a93abd8f1c02454d27
</code></pre>
			</codesample>
		</div>
	</span>
</div>
</div>
%next 1
%empty

<div class="rec-outer">
<div class="record client">
<div class="rec-label">Wrapped Record</div>
<div class="rec-explanation">
	To reduce issues with middleboxes that block unrecognized
	TLS protocols, TLS 1.3 records are disguised as TLS 1.2
	application data records.
	<br/><br/>
	The wrapped record is discussed in its own section below this one.
</div>
%file ../captures/caps/clientencdata
<span class="record-data">
	<span class="string">
		<span class="label">Record Header</span>
		<span class="bytes">
%next 5
%bytes
		</span>
		<div class="explanation">
			The TLS 1.3 record is encrypted into a TLS
			1.2 record "wrapper" that looks like
			application data.
			<ul>
			<li><tt>%0</tt> - type is 0x17 (application data)
			<li><tt>%1 %2</tt> - legacy protocol version of "3,3" (TLS 1.2)
			<li><tt>%3 %4</tt> - the length of the record payload is %nn3 bytes
			</ul>
			All data following this header is the encrypted form of the actual record.
		</div>
	</span>

	<span class="string encrypted">
		<span class="label">Encrypted Data</span>
		<span class="bytes">
%next 5
%bytes
		</span>
		<div class="explanation">
			This data is encrypted with the client application key.
			<br/><br/>
			See below for the decrypted data.
		</div>
	</span>

	<span class="string">
		<span class="label">Auth Tag</span>
		<span class="bytes">
%next 16
%bytes
		</span>
		<div class="explanation">
			This is the AEAD authentication tag
			that protects the integrity of the
			encrypted data and the record header.
		</div>
	</span>
%empty

	<div class="decryption">
		<div class="label">Decryption</div>
		<div class="explanation">
			This data is encrypted using the client
			application key and the client application IV that were
			generated during the "Client Application Keys
			Calc" step.  The IV will be modified
			by XOR'ing it by the count of records that
			have already been encrypted with this key,
			which in this case is 0.  The process also
			takes as input the 5-byte record header
			that this record begins with, as authenticated
			data that must match for the decryption to
			succeed.
			<br/><br/>
			Because the <tt>openssl</tt> command line
			tool does not yet support AEAD ciphers,
			I've written command line tools to both
			<a href="files/aes_256_gcm_decrypt.c" download="aes_256_gcm_decrypt.c">decrypt</a>
			and <a href="files/aes_256_gcm_encrypt.c" download="aes_256_gcm_encrypt.c">encrypt</a>
			this data.
			<codesample>
<pre><code>### from the "Client Application Keys Calc" step
$ key=de2f4c7672723a692319873e5c227606691a32d1c59d8b9f51dbb9352e9ca9cc
$ iv=bb007956f474b25de902432f
### from this record
$ recdata=1703030015
$ authtag=73aaabf5b82fbf9a2961bcde10038a32
$ recordnum=0
### may need to add -I and -L flags for include and lib dirs
$ cc -o aes_256_gcm_decrypt aes_256_gcm_decrypt.c -lssl -lcrypto
$ echo "82 81 39 cb 7b" | xxd -r -p > /tmp/msg3
$ cat /tmp/msg3 \
  | ./aes_256_gcm_decrypt $iv $recordnum $key $recdata $authtag \
  | hexdump -C

00000000  70 69 6e 67 17                                    |ping.|
</code></pre>
			</codesample>
		</div>
	</div>

%file ../captures/caps/clientdata
	<span class="string decrypted">
		<span class="label">Client Application Data</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			This application data is represented in its own section below.
		</div>
	</span>

	<span class="string decrypted">
		<span class="label">Record Type</span>
		<span class="bytes">
%next 1
%bytes
		</span>
		<div class="explanation">
			Each TLS 1.3 record disguised as TLS 1.2
			application data has a final byte
			which indicates its actual record type.
			<ul>
			<li><tt>%0</tt> - type is 0x17 (application data)
			</ul>
		</div>
	</span>
</span>
</div>
</div>
%empty

<div class="rec-outer">
<div class="record client embedded">
<div class="rec-label">Client Application Data</div>
<div class="rec-explanation">
	The client sends the data "ping".
</div>
%file ../captures/caps/clientdata
<span class="record-data">
	<span class="string">
		<span class="label">Application Data</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			The bytes "ping".
		</div>
	</span>
</span>
</div>
</div>
%next 1
%empty


<div class="rec-outer">
<div class="record server">
<div class="rec-label">Wrapped Record</div>
<div class="rec-explanation">
	To reduce issues with middleboxes that block unrecognized
	TLS protocols, TLS 1.3 records are disguised as TLS 1.2
	application data records.
	<br/><br/>
	The wrapped records are discussed in their own sections below this one.
</div>
%file ../captures/caps/serverencticket1
<span class="record-data">
	<span class="string">
		<span class="label">Record Header</span>
		<span class="bytes">
%next 5
%bytes
		</span>
		<div class="explanation">
			The TLS 1.3 record is encrypted into a TLS
			1.2 record "wrapper" that looks like
			application data.
			<ul>
			<li><tt>%0</tt> - type is 0x17 (application data)
			<li><tt>%1 %2</tt> - legacy protocol version of "3,3" (TLS 1.2)
			<li><tt>%3 %4</tt> - the length of the record payload is %nn3 bytes
			</ul>
			All data following this header is the encrypted form of the actual record.
		</div>
	</span>

	<span class="string encrypted">
		<span class="label">Encrypted Data</span>
		<span class="bytes">
%next 218
%bytes
		</span>
		<div class="explanation">
			This data is encrypted with the server application key.
			<br/><br/>
			See below for the decrypted data.
		</div>
	</span>

	<span class="string">
		<span class="label">Auth Tag</span>
		<span class="bytes">
%next 16
%bytes
		</span>
		<div class="explanation">
			This is the AEAD authentication tag
			that protects the integrity of the
			encrypted data and the record header.
		</div>
	</span>
%empty

	<div class="decryption">
		<div class="label">Decryption</div>
		<div class="explanation">
			This data is encrypted using the server
			application key and the server application IV that were
			generated during the "Server Application Keys
			Calc" step.  The IV will be modified
			by XOR'ing it by the count of records that
			have already been encrypted with this key,
			which in this case is 0.  The process also
			takes as input the 5-byte record header
			that this record begins with, as authenticated
			data that must match for the decryption to
			succeed.
			<br/><br/>
			Because the <tt>openssl</tt> command line
			tool does not yet support AEAD ciphers,
			I've written command line tools to both
			<a href="files/aes_256_gcm_decrypt.c" download="aes_256_gcm_decrypt.c">decrypt</a>
			and <a href="files/aes_256_gcm_encrypt.c" download="aes_256_gcm_encrypt.c">encrypt</a>
			this data.
			<codesample>
<pre><code>### from the "Server Application Keys Calc" step
$ key=01f78623f17e3edcc09e944027ba3218d57c8e0db93cd3ac419309274700ac27
$ iv=196a750b0c5049c0cc51a541
### from this record
$ recdata=17030300ea
$ authtag=38d9db1f91ca3d5842602a610b43a463
$ recordnum=0
### may need to add -I and -L flags for include and lib dirs
$ cc -o aes_256_gcm_decrypt aes_256_gcm_decrypt.c -lssl -lcrypto
$ echo "38 2d 8c 19 a4 7f 4e 8d 9b 0c 51 0b c3 48 db 2c c9 9b 24
  ... snip ...
  13 c1 6e 88 61 1d 3e ae 93" | xxd -r -p > /tmp/msg5
$ cat /tmp/msg5 \
  | ./aes_256_gcm_decrypt $iv $recordnum $key $recdata $authtag \
  | hexdump -C

00000000  04 00 00 d5 00 00 1c 20  00 00 00 00 08 00 00 00  |....... ........|
00000010  00 00 00 00 00 00 c0 41  42 43 44 45 46 47 48 49  |.......ABCDEFGHI|
... snip ...
</code></pre>
			</codesample>
		</div>
	</div>

%file ../captures/caps/serverticket1
	<span class="string decrypted">
		<span class="label">Server New Session Ticket 1</span>
		<span class="bytes">
%next 217
%bytes
		</span>
		<div class="explanation">
			This handshake message is represented in its own section below.
		</div>
	</span>

	<span class="string decrypted">
		<span class="label">Record Type</span>
		<span class="bytes">
%next 1
%bytes
		</span>
		<div class="explanation">
			Each TLS 1.3 record disguised as TLS 1.2
			application data has a final byte
			which indicates its actual record type.
			<ul>
			<li><tt>%0</tt> - type is 0x16 (handshake data)
			</ul>
		</div>
	</span>
</span>
</div>
</div>
%empty


<div class="rec-outer">
<div class="record server embedded">
<div class="rec-label">Server New Session Ticket 1</div>
<div class="rec-explanation">
	The server provides a session ticket that the client can
	use to start a new session later.  Successfully resuming a
	connection in this way will skip most of the computation
	and network delay in session startup.
	<br/><br/>
	Because each session ticket is meant to be single-use, and
	because the server expects a browser to open multiple
	connections, it makes a size vs. speed decision to provide
	the client with two session tickets for each negotiated
	session.  This is the first ticket.
</div>
%file ../captures/caps/serverticket1
<span class="record-data">
	<span class="string">
		<span class="label">Handshake Header</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<ul>
			<li><tt>%0</tt> - handshake message type 0x04 (new session ticket)
			<li><tt>%1 %2 %3</tt> - %nnn1 bytes of session ticket data follow
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Ticket Lifetime</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			The ticket lifetime of %nnnn0 seconds, or 2 hours.
		</div>
	</span>

	<span class="string">
		<span class="label">Ticket Age Add</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			When sending this ticket back to the server,
			it must add this number of milliseconds to
			the timestamp indicating when the ticket
			was generated.  This prevents attackers
			from correlating the resumed session with
			the session that generated this ticket.
		</div>
	</span>

	<span class="string">
		<span class="label">Ticket Nonce</span>
		<span class="bytes">
%next 9
%bytes
		</span>
		<div class="explanation">
			A per-ticket value that is unique to each
			ticket generated during this session.
			<ul>
			<li><tt>%0</tt> - %n0 bytes of nonce data follows
			<li><tt>%1 %2 %3 %5 %6 %7 %8</tt> - nonce value
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Session Ticket</span>
		<span class="bytes">
%next 194
%bytes
		</span>
		<div class="explanation">
			This is the ticket that can be sent to the
			server to resume a session.  The data inside
			is meaningful to the server, and
			may contain enough information for the
			server to safely resume the connection
			without storing any information on the
			server (such as in memory).  This information
			is not meaningful or understandable to the
			client.

			<ul>
			<li><tt>%0 %1</tt> - %nn0 bytes of ticket data follows
			<li><tt>%2 %3 ... %-2 %-1</tt> - session ticket
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Ticket Extensions</span>
		<span class="bytes">
%next 2
%bytes
		</span>
		<div class="explanation">
			The server provides extensions to provide
			more information about the ticket or to
			request a behavioral change from the client.
			<br/><br/>
			<ul>
			<li><tt>%0 %1</tt> - %n0 bytes of "Ticket Extensions" extension data follows
			</ul>
		</div>
	</span>
</span>
</div>
</div>
%next 1
%empty


<div class="rec-outer">
<div class="record server">
<div class="rec-label">Wrapped Record</div>
<div class="rec-explanation">
	To reduce issues with middleboxes that block unrecognized
	TLS protocols, TLS 1.3 records are disguised as TLS 1.2
	application data records.
	<br/><br/>
	The wrapped records are discussed in their own sections below this one.
</div>
%file ../captures/caps/serverencticket2
<span class="record-data">
	<span class="string">
		<span class="label">Record Header</span>
		<span class="bytes">
%next 5
%bytes
		</span>
		<div class="explanation">
			The TLS 1.3 record is encrypted into a TLS
			1.2 record "wrapper" that looks like
			application data.
			<ul>
			<li><tt>%0</tt> - type is 0x17 (application data)
			<li><tt>%1 %2</tt> - legacy protocol version of "3,3" (TLS 1.2)
			<li><tt>%3 %4</tt> - the length of the record payload is %nn3 bytes
			</ul>
			All data following this header is the encrypted form of the actual record.
		</div>
	</span>

	<span class="string encrypted">
		<span class="label">Encrypted Data</span>
		<span class="bytes">
%next 218
%bytes
		</span>
		<div class="explanation">
			This data is encrypted with the server application key.
			<br/><br/>
			See below for the decrypted data.
		</div>
	</span>

	<span class="string">
		<span class="label">Auth Tag</span>
		<span class="bytes">
%next 16
%bytes
		</span>
		<div class="explanation">
			This is the AEAD authentication tag
			that protects the integrity of the
			encrypted data and the record header.
		</div>
	</span>
%empty

	<div class="decryption">
		<div class="label">Decryption</div>
		<div class="explanation">
			This data is encrypted using the server
			application key and the server application IV that were
			generated during the "Server Application Keys
			Calc" step.  The IV will be modified
			by XOR'ing it by the count of records that
			have already been encrypted with this key,
			which in this case is 1.  The process also
			takes as input the 5-byte record header
			that this record begins with, as authenticated
			data that must match for the decryption to
			succeed.
			<br/><br/>
			Because the <tt>openssl</tt> command line
			tool does not yet support AEAD ciphers,
			I've written command line tools to both
			<a href="files/aes_256_gcm_decrypt.c" download="aes_256_gcm_decrypt.c">decrypt</a>
			and <a href="files/aes_256_gcm_encrypt.c" download="aes_256_gcm_encrypt.c">encrypt</a>
			this data.
			<codesample>
<pre><code>### from the "Server Application Keys Calc" step
$ key=01f78623f17e3edcc09e944027ba3218d57c8e0db93cd3ac419309274700ac27
$ iv=196a750b0c5049c0cc51a541
### from this record
$ recdata=17030300ea
$ authtag=c0b96ad383afbd8dfc86f8087c1f7dc8
$ recordnum=1
### may need to add -I and -L flags for include and lib dirs
$ cc -o aes_256_gcm_decrypt aes_256_gcm_decrypt.c -lssl -lcrypto
$ echo "38 ad fb 1d 01 fd 95 a6 03 85 e8 bb f1 fd 8d cb 46 70
  ... snip ...
  b4 0a 1e f1 85 74 ef" | xxd -r -p > /tmp/msg5
$ cat /tmp/msg5 \
  | ./aes_256_gcm_decrypt $iv $recordnum $key $recdata $authtag \
  | hexdump -C

00000000  04 00 00 d5 00 00 1c 20  00 00 00 00 08 00 00 00  |....... ........|
00000010  00 00 00 00 01 00 c0 41  42 43 44 45 46 47 48 49  |.......ABCDEFGHI|
... snip ...
</code></pre>
			</codesample>
		</div>
	</div>

%file ../captures/caps/serverticket2
	<span class="string decrypted">
		<span class="label">Server New Session Ticket 2</span>
		<span class="bytes">
%next 217
%bytes
		</span>
		<div class="explanation">
			This handshake message is represented in its own section below.
		</div>
	</span>

	<span class="string decrypted">
		<span class="label">Record Type</span>
		<span class="bytes">
%next 1
%bytes
		</span>
		<div class="explanation">
			Each TLS 1.3 record disguised as TLS 1.2
			application data has a final byte
			which indicates its actual record type.
			<ul>
			<li><tt>%0</tt> - type is 0x16 (handshake data)
			</ul>
		</div>
	</span>
</span>
</div>
</div>
%empty


<div class="rec-outer">
<div class="record server embedded">
<div class="rec-label">Server New Session Ticket 2</div>
<div class="rec-explanation">
	The server provides a session ticket that the client can
	use to start a new session later.  Successfully resuming a
	connection in this way will skip most of the computation
	and network delay in session startup.
	<br/><br/>
	Because each session ticket is meant to be single-use, and
	because the server expects a browser to open multiple
	connections, it makes a size vs. speed decision to provide
	the client with two session tickets for each negotiated
	session.  This is the second ticket.
</div>
%file ../captures/caps/serverticket2
<span class="record-data">
	<span class="string">
		<span class="label">Handshake Header</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<ul>
			<li><tt>%0</tt> - handshake message type 0x04 (new session ticket)
			<li><tt>%1 %2 %3</tt> - %nnn1 bytes of session ticket data follow
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Ticket Lifetime</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			The ticket lifetime of %nnnn0 seconds, or 2 hours.
		</div>
	</span>

	<span class="string">
		<span class="label">Ticket Age Add</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			When sending this ticket back to the server,
			it must add this number of milliseconds to
			the timestamp indicating when the ticket
			was generated.  This prevents attackers
			from correlating the resumed session with
			the session that generated this ticket.
		</div>
	</span>

	<span class="string">
		<span class="label">Ticket Nonce</span>
		<span class="bytes">
%next 9
%bytes
		</span>
		<div class="explanation">
			A per-ticket value that is unique to each
			ticket generated during this session.
			<ul>
			<li><tt>%0</tt> - %n0 bytes of nonce data follows
			<li><tt>%1 %2 %3 %5 %6 %7 %8</tt> - nonce value
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Session Ticket</span>
		<span class="bytes">
%next 194
%bytes
		</span>
		<div class="explanation">
			This is the ticket that can be sent to the
			server to resume a session.  The data inside
			is meaningful to the server, and
			may contain enough information for the
			server to safely resume the connection
			without storing any information on the
			server (such as in memory).  This information
			is not meaningful or understandable to the
			client.

			<ul>
			<li><tt>%0 %1</tt> - %nn0 bytes of ticket data follows
			<li><tt>%2 %3 ... %-2 %-1</tt> - session ticket
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Ticket Extensions</span>
		<span class="bytes">
%next 2
%bytes
		</span>
		<div class="explanation">
			The server provides extensions to provide
			more information about the ticket or to
			request a behavioral change from the client.
			<br/><br/>
			<ul>
			<li><tt>%0 %1</tt> - %n0 bytes of "Ticket Extensions" extension data follows
			</ul>
		</div>
	</span>
</span>
</div>
</div>
%next 1
%empty


<div class="rec-outer">
<div class="record server">
<div class="rec-label">Wrapped Record</div>
<div class="rec-explanation">
	To reduce issues with middleboxes that block unrecognized
	TLS protocols, TLS 1.3 records are disguised as TLS 1.2
	application data records.
	<br/><br/>
	The wrapped record is discussed in its own section below this one.
</div>
%file ../captures/caps/serverencdata
<span class="record-data">
	<span class="string">
		<span class="label">Record Header</span>
		<span class="bytes">
%next 5
%bytes
		</span>
		<div class="explanation">
			The TLS 1.3 record is encrypted into a TLS
			1.2 record "wrapper" that looks like
			application data.
			<ul>
			<li><tt>%0</tt> - type is 0x17 (application data)
			<li><tt>%1 %2</tt> - legacy protocol version of "3,3" (TLS 1.2)
			<li><tt>%3 %4</tt> - the length of the record payload is %nn3 bytes
			</ul>
			All data following this header is the encrypted form of the actual record.
		</div>
	</span>

	<span class="string encrypted">
		<span class="label">Encrypted Data</span>
		<span class="bytes">
%next 5
%bytes
		</span>
		<div class="explanation">
			This data is encrypted with the server application key.
			<br/><br/>
			See below for the decrypted data.
		</div>
	</span>

	<span class="string">
		<span class="label">Auth Tag</span>
		<span class="bytes">
%next 16
%bytes
		</span>
		<div class="explanation">
			This is the AEAD authentication tag
			that protects the integrity of the
			encrypted data and the record header.
		</div>
	</span>
%empty

	<div class="decryption">
		<div class="label">Decryption</div>
		<div class="explanation">
			This data is encrypted using the server
			application key and the server application IV that were
			generated during the "Server Application Keys
			Calc" step.  The IV will be modified
			by XOR'ing it by the count of records that
			have already been encrypted with this key,
			which in this case is 2.  The process also
			takes as input the 5-byte record header
			that this record begins with, as authenticated
			data that must match for the decryption to
			succeed.
			<br/><br/>
			Because the <tt>openssl</tt> command line
			tool does not yet support AEAD ciphers,
			I've written command line tools to both
			<a href="files/aes_256_gcm_decrypt.c" download="aes_256_gcm_decrypt.c">decrypt</a>
			and <a href="files/aes_256_gcm_encrypt.c" download="aes_256_gcm_encrypt.c">encrypt</a>
			this data.
			<codesample>
<pre><code>### from the "Server Application Keys Calc" step
$ key=01f78623f17e3edcc09e944027ba3218d57c8e0db93cd3ac419309274700ac27
$ iv=196a750b0c5049c0cc51a541
### from this record
$ recdata=1703030015
$ authtag=7ae23fa66d56f4c5408482b1b1d4c998
$ recordnum=2
### may need to add -I and -L flags for include and lib dirs
$ cc -o aes_256_gcm_decrypt aes_256_gcm_decrypt.c -lssl -lcrypto
$ echo "0c da 85 f1 44" | xxd -r -p > /tmp/msg4
$ cat /tmp/msg4 \
  | ./aes_256_gcm_decrypt $iv $recordnum $key $recdata $authtag \
  | hexdump -C

00000000  70 6f 6e 67 17                                    |pong.|
</code></pre>
			</codesample>
		</div>
	</div>

%file ../captures/caps/serverdata
	<span class="string decrypted">
		<span class="label">Server Application Data</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			This application data is represented in its own section below.
		</div>
	</span>

	<span class="string decrypted">
		<span class="label">Record Type</span>
		<span class="bytes">
%next 1
%bytes
		</span>
		<div class="explanation">
			Each TLS 1.3 record disguised as TLS 1.2
			application data has a final byte
			which indicates its actual record type.
			<ul>
			<li><tt>%0</tt> - type is 0x17 (application data)
			</ul>
		</div>
	</span>
</span>
</div>
</div>
%empty

<div class="rec-outer">
<div class="record server embedded">
<div class="rec-label">Server Application Data</div>
<div class="rec-explanation">
	The server replies with the data "pong".
</div>
%file ../captures/caps/serverdata
<span class="record-data">
	<span class="string">
		<span class="label">Application Data</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			The bytes "pong".
		</div>
	</span>
</span>
</div>
</div>
%next 1
%empty

	<div class="outerblock">
	<p>The code for this project can be found
	<a href="https://github.com/syncsynchalt/illustrated-tls13">on GitHub</a>.</p>
	</div>

	<div class="outerblock">
	<p>If you found this page useful or interesting let me know via Twitter
	<a href="https://twitter.com/xargsnotbombs">@XargsNotBombs</a>.</p>
	</div>

</div>

<div id="templates" style="display: none">
	<div id="closeBtnTmpl">
		<span class="close" onclick="ill.unselectAllStrings()"></span>
	</div>
	<div id="showCodeTmpl">
		<button class="show-code" onclick="ill.showCode(this, event)">Show Code</button>
	</div>
	<button id="annotateTmpl" class="annotate-toggle"
		onclick="ill.toggleAnnotate(this.parentElement, event)">Annotations</button>
</div>

<a class="print-mode" href="#print" onclick="ill.printMode()">
	[print]
</a>
</body>
</html>
