<!doctype html>
<html>

<head>
	<title>The Illustrated TLS 1.3 Connection: Every Byte Explained</title>
	<meta charset="utf-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/>
	<meta name="format-detection" content="telephone=no"/>
	<meta name="title" content="The Illustrated TLS 1.3 Connection"/>
	<meta name="description" content="Every byte of a TLS 1.3 connection explained and reproduced"/>
	<link rel="stylesheet" href="frombootstrap.css"/>
	<link rel="stylesheet" href="illustrated.css"/>
	<script src="illustrated.js"></script>
</head>

<body class="illustrated">
<div class="container">
	<h1>The Illustrated TLS 1.3 Connection</h1>

	<h3>Every byte explained and reproduced</h3>

	<div class="outerblock">
	<p>In this demonstration a client connects to a server,
	negotiates a TLS 1.3 session, sends "ping", receives "pong",
	and then terminates the session. Click below to begin
	exploring.</p>
	</div>

<div class="rec-outer">
<div class="calculation client">
<div class="rec-label">Client Key Exchange Generation</div>
<img class="illustration" src="images/key6.png" width="105" height="250"/>
<div class="rec-explanation">
	The client begins by calculating a private/public keypair
	for key exchange.  Key exchange is a mathematical technique
	by which two parties can agree on the same number without
	an eavesdropper being able to tell what that number is.
	<br/><br/>
	It will do this via an elliptical curve method, using the x25519 curve.
	<br/><br/>
	The private key is chosen by selecting an integer between
	0 and 2<sup>256</sup>-1.  It does this by generating 32
	bytes (256 bits) of random data.  The
	<a href="files/client-ephemeral-private.key" download="client-ephemeral-private.key">private key</a>
	selected is:

	<pre class="ind2"><tt class="longboi">202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f</tt></pre>

	The <a href="files/client-ephemeral-public.key" download="client-ephemeral-public.key">public key</a>
	is chosen by multiplying the point x=9 on the x25519 curve
	by the private key.  The public key calculated is:

	<pre class="ind2"><tt class="longboi">358072d6365880d1aeea329adf9121383851ed21a28e3b75e965d0d2cd166254</tt></pre>

	The public key calculation can be confirmed at the command line:
	<codesample>
<pre><code>### requires openssl 1.1.0 or higher
$ openssl pkey -noout -text &lt; client-ephemeral-private.key

X25519 Private-Key:
priv:
    20:21:22:23:24:25:26:27:28:29:2a:2b:2c:2d:2e:
    2f:30:31:32:33:34:35:36:37:38:39:3a:3b:3c:3d:
    3e:3f
pub:
    35:80:72:d6:36:58:80:d1:ae:ea:32:9a:df:91:21:
    38:38:51:ed:21:a2:8e:3b:75:e9:65:d0:d2:cd:16:
    62:54
</code></pre>
	</codesample>
</div>
</div>
</div>

<div class="rec-outer">
<div class="record client">
<div class="rec-label">Client Hello</div>
<img class="illustration" src="images/key1.png" width="135" height="250"/>
<div class="rec-explanation">
	The session begins with the client saying "Hello".
	The client provides information including the following:
	<ul>
	<li>client random data (used later in the handshake)
	<li>a list of cipher suites that the client supports
	<li>a list of public keys that the server might find suitable for key exchange
	<li>protocol versions that the client can support
	</ul>
</div>
%file ../captures/caps/clienthello
<span class="record-data">
	<span class="string">
		<span class="label">Record Header</span>
		<span class="bytes">
%next 5
%bytes
		</span>
		<div class="explanation">
			TLS sessions are broken into the sending
			and receiving of "records", which are blocks
			of data with a type, a protocol version,
			and a length.
			<ul>
			<li><tt>%0</tt> - type is 0x16 (handshake record)
			<li><tt>%1 %2</tt> - protocol version is 3.1 (also known as TLS 1.0)
			<li><tt>%3 %4</tt> - %xx3 (%dd3) bytes of handshake message follows
			</ul>
			Interestingly the version in this record
			is 3.1 (TLS 1.0) instead of 3.4 (TLS 1.3).
			This is done for interoperability with earlier
			implementations.
		</div>
	</span>

	<span class="string">
		<span class="label">Handshake Header</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<ul>
			<li><tt>%0</tt> - handshake message type 0x01 (client hello)
			<li><tt>%1 %2 %3</tt> - %xxx1 (%ddd1) bytes of client hello data follows
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Client Version</span>
		<span class="bytes">
%next 2
%bytes
		</span>
		<div class="explanation">
			A protocol version of 3.3 (meaning TLS 1.2)
			is given.  Because middleboxes have been
			created and widely deployed that do not
			allow protocol versions that
			they do not recognize, the TLS 1.3 session
			must be disguised as a TLS 1.2 session.
			This field is no
			longer used for version negotiation and
			is hardcoded to the 1.2 version.  Instead
			version negotiation is performed using the
			"Supported Versions" extension below.
			<br/><br/>
			The particular version number (3.3 representing
			version 1.2) is due to TLS 1.0 being a minor
			revision of the SSL 3.0 protocol.  Therefore
			TLS 1.0 is numeric version 3.1, TLS 1.1 is version
			3.2, and so on.
		</div>
	</span>

	<span class="string">
		<span class="label">Client Random</span>
		<span class="bytes">
%next 32
%bytes
		</span>
		<div class="explanation">
			The client provides 32 bytes of random data.
			In this example we've made the random data a predictable string.
		</div>
	</span>

	<span class="string">
		<span class="label">Session ID</span>
		<span class="bytes">
%next 33
%bytes
		</span>
		<div class="explanation">
			In previous versions of TLS the client could
			provide an ID of a previously negotiated
			session, which allows the server and client
			to skip the time and cost of negotiating new keys.
			<br/><br/>
			In TLS 1.3 this "session resume" is done via the more flexible
			PSK (pre-shared keys) mechanism, so this
			field is no longer needed for that purpose.
			Instead a non-empty value in this field is
			used to trigger "middlebox compatibility
			mode" which helps TLS 1.3 sessions to be
			disguised as resumed TLS 1.2 sessions.  The
			client has generated random data to populate
			this field.
			<ul>
			<li><tt>%0</tt> - %x0 (%d0) bytes of session ID follow
			<li><tt>%1 %2 ... %-2 %-1</tt> - fake session ID
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Cipher Suites</span>
		<span class="bytes">
%next 8
%bytes
		</span>
		<div class="explanation">
			The client provides an ordered list of which
			cipher suites it will support for encryption.
			The list is in the order preferred by the
			client, with highest preference first.
			<br/><br/>
			In TLS 1.3 the list of possible cipher
			suites has been greatly reduced.  All the
			remaining suites are AEAD algorithms which
			provide stronger encryption guarantees than
			many previous suites with an easier all-in-one
			implementation.
			<ul>
			<li><tt>%0 %1</tt> - %xx0 (%dd0) bytes of cipher suite data
			<li><tt>13 01</tt> - assigned value for <tt>AES-128-GCM-SHA256</tt>
			<li><tt>13 02</tt> - assigned value for <tt>AES-128-GCM-SHA384</tt>
			<li><tt>13 03</tt> - assigned value for <tt>CHACHA20-POLY1305-SHA256</tt>
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Compression Methods</span>
		<span class="bytes">
%next 2
%bytes
		</span>
		<div class="explanation">
			Previous versions of TLS supported
			compression, which was found to leak
			information about the encrypted data allowing
			it to be read (see <a href="https://en.wikipedia.org/wiki/CRIME">CRIME</a>
			and <a href="https://en.wikipedia.org/wiki/BREACH">BREACH</a>).
			<br/><br/>
			TLS 1.3 no longer allows compression, so
			this field is always a single entry with
			the "null" compression method which performs
			no change to the data.
			<ul>
			<li><tt>%0</tt> - %x0 (%d0) bytes of compression methods
			<li><tt>00</tt> - assigned value for "null" compression
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Extensions Length</span>
		<span class="bytes">
%next 2
%bytes
		</span>
		<div class="explanation">
			The client has provided a list of optional
			extensions which the server can use to
			take action or enable new features.
			<ul>
			<li><tt>%0 %1</tt> - the extensions will take %xx0 (%dd0) bytes of data
			</ul>
			Each extension will start with two bytes
			that indicate which extension it is, followed
			by a two-byte content length field, followed
			by the contents of the extension.
		</div>
	</span>

	<span class="string">
		<span class="label">Extension - Server Name</span>
		<span class="bytes">
%next 28
%bytes
		</span>
		<div class="explanation">
			The client has provided the name of the
			server it is contacting, also known as SNI
			(Server Name Indication).
			<br/><br/>
			Without this extension a HTTPS server would
			not be able to provide service for multiple
			hostnames (virtual hosts) on a single IP address
			because it couldn't know which
			hostname's certificate to send until
			after the TLS session was negotiated and the
			HTTP request was made.
			<ul>
				<li><tt>00 00</tt> - assigned value for extension "server name"
				<li><tt>%2 %3</tt> - %xx2 (%dd2) bytes of extension data follows
				<li><tt>%4 %5</tt> - %xx4 (%dd4) bytes of first (and only) list entry follows
				<li><tt>%6</tt> - list entry is type 0x00 "DNS hostname"
				<li><tt>%7 %8</tt> - %xx7 (%dd7) bytes of hostname follows
				<li><tt>%9 %10 %11 ... %-3 %-2 %-1</tt> - "example.ulfheim.net"
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Extension - Supported Groups</span>
		<span class="bytes">
%next 12
%bytes
		</span>
		<div class="explanation">
			The client has indicated that it supports
			elliptic curve (EC) cryptography for three curve types.
			To make this extension more generic for
			other cryptography types it now calls these
			"supported groups" instead of "supported
			curves".
			<br/><br/>
			This list is presented in descending order
			of the client's preference.
			<ul>
				<li><tt>00 0a</tt> - assigned value for extension "supported groups"
				<li><tt>%2 %3</tt> - %xx2 (%dd2) bytes of extension data follows
				<li><tt>%4 %5</tt> - %xx4 (%dd4) bytes of data are in the curves list
				<li><tt>00 1d</tt> - assigned value for the curve "x25519"
				<li><tt>00 17</tt> - assigned value for the curve "secp256r1"
				<li><tt>00 18</tt> - assigned value for the curve "secp384r1"
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Extension - Signature Algorithms</span>
		<span class="bytes">
%next 24
%bytes
		</span>
		<div class="explanation">
			This extension indicates which signature
			algorithms the client supports.  This can
			influence the certificate that the server
			presents to the client, as well as the
			signature that is sent by the server in
			the CertificateVerify record.
			<br/><br/>
			This list is presented in descending order
			of the client's preference.
			<ul>
				<li><tt>00 0d</tt> - assigned value for extension "Signature Algorithms"
				<li><tt>%2 %3</tt> - %xx2 (%dd2) bytes of extension data follows
				<li><tt>%4 %5</tt> - %xx4 (%dd4) bytes of data are in the following list of algorithms
				<li><tt>04 03</tt> - assigned value for ECDSA-SECP256r1-SHA256
				<li><tt>08 04</tt> - assigned value for RSA-PSS-RSAE-SHA256
				<li><tt>04 01</tt> - assigned value for RSA-PKCS1-SHA256
				<li><tt>05 03</tt> - assigned value for ECDSA-SECP384r1-SHA384
				<li><tt>08 05</tt> - assigned value for RSA-PSS-RSAE-SHA384
				<li><tt>05 01</tt> - assigned value for RSA-PKCS1-SHA386
				<li><tt>08 06</tt> - assigned value for RSA-PSS-RSAE-SHA512
				<li><tt>06 01</tt> - assigned value for RSA-PKCS1-SHA512
				<li><tt>02 01</tt> - assigned value for RSA-PKCS1-SHA1
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Extension - Key Share</span>
		<span class="bytes">
%next 42
%bytes
		</span>
		<div class="explanation">
			The client sends one or more public keys
			using an algorithm that it thinks the server
			will support.  This allows the
			rest of the handshake after the ClientHello
			and ServerHello messages to be encrypted,
			unlike previous protocol versions where the
			handshake was sent in the clear.
			<ul>
				<li><tt>00 33</tt> - assigned value for extension "Key Share"
				<li><tt>%2 %3</tt> - %xx2 (%dd2) bytes of extension data follows
				<li><tt>%4 %5</tt> - %xx4 (%dd4) bytes of key share data follows
				<li><tt>00 1d</tt> - assigned value for x25519 (key exchange via curve25519)
				<li><tt>%8 %9</tt> - %xx8 (%dd8) bytes of public key follows
				<li><tt>%10 %11 ... %-2 %-1</tt></l> - public key from the step "Client Key Exchange Generation"
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Extension - PSK Key Exchange Modes</span>
		<span class="bytes">
%next 6
%bytes
		</span>
		<div class="explanation">
			The client indicates the modes available
			for establishing keys from pre-shared keys
			(PSKs).  Since we do not use PSKs in this
			session, this extension has no effect.
			<ul>
				<li><tt>00 2d</tt> - assigned value for extension "PSK Key Exchange Modes"
				<li><tt>%2 %3</tt> - %xx2 (%dd2) bytes of extension data follows
				<li><tt>%4</tt> - %x4 (%d4) bytes of exchange modes follow
				<li><tt>01</tt> - assigned value for "PSK with (EC)DHE key establishment"
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Extension - Supported Versions</span>
		<span class="bytes">
%next 7
%bytes
		</span>
		<div class="explanation">
			The client indicates its support of TLS 1.3.
			<ul>
				<li><tt>00 2b</tt> - assigned value for extension "Supported Versions"
				<li><tt>%2 %3</tt> - %xx2 (%dd2) bytes of extension data follows
				<li><tt>%4</tt> - %x4 (%d4) bytes of TLS versions follow
				<li><tt>03 04</tt> - assigned value for TLS 1.3
			</ul>
		</div>
	</span>

</span>
</div>
</div>
%empty

<div class="rec-outer">
<div class="calculation server">
<div class="rec-label">Server Key Exchange Generation</div>
<img class="illustration" src="images/key4.png" width="106" height="250"/>
<div class="rec-explanation">
	The server calculates a private/public keypair
	for key exchange.  Key exchange is a mathematical technique
	by which two parties can agree on the same number without
	an eavesdropper being able to tell what that number is.
	<br/><br/>
	It will do this via an elliptical curve method, using the x25519 curve.
	<br/><br/>
	The private key is chosen by selecting an integer between
	0 and 2<sup>256</sup>-1.  It does this by generating 32
	bytes (256 bits) of random data.  The
	<a href="files/server-ephemeral-private.key" download="server-ephemeral-private.key">private key</a>
	selected is:

<pre class="ind2"><tt class="longboi">909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeaf</tt></pre>

	The <a href="files/server-ephemeral-public.key" download="server-ephemeral-public.key">public key</a>
	is chosen by multiplying the point x=9 on the x25519 curve
	by the private key.  The public key calculated is:

<pre class="ind2"><tt class="longboi">9fd7ad6dcff4298dd3f96d5b1b2af910a0535b1488d7f8fabb349a982880b615</tt></pre>

	The public key calculation can be confirmed with command line tools:
	<codesample>
<pre><code>### requires openssl 1.1.0 or higher
$ openssl pkey -noout -text &lt; server-ephemeral-private.key

X25519 Private-Key:
priv:
    90:91:92:93:94:95:96:97:98:99:9a:9b:9c:9d:9e:
    9f:a0:a1:a2:a3:a4:a5:a6:a7:a8:a9:aa:ab:ac:ad:
    ae:af
pub:
    9f:d7:ad:6d:cf:f4:29:8d:d3:f9:6d:5b:1b:2a:f9:
    10:a0:53:5b:14:88:d7:f8:fa:bb:34:9a:98:28:80:
    b6:15
</code></pre>
	</codesample>
</div>
</div>
</div>
%empty

<div class="rec-outer">
<div class="record server">
<div class="rec-label">Server Hello</div>
<img class="illustration" src="images/key2.png" width="124" height="250"/>
<div class="rec-explanation">
	The server says "Hello" back.  The server provides information including the following:
	<ul>
	<li>server random data (used later in the handshake)
	<li>a selected cipher suite
	<li>a public key for key exchange
	<li>the negotiated protocol version
	</ul>
</div>
%file ../captures/caps/serverhello
<span class="record-data">
	<span class="string">
		<span class="label">Record Header</span>
		<span class="bytes">
%next 5
%bytes
		</span>
		<div class="explanation">
			TLS sessions are broken into the sending
			and receiving of "records", which are blocks
			of data with a type, a protocol version,
			and a length.
			<ul>
			<li><tt>%0</tt> - type is 0x16 (handshake record)
			<li><tt>%1 %2</tt> - legacy protocol version of 3.3 (TLS 1.2)
			<li><tt>%3 %4</tt> - %xx3 (%dd3) bytes of handshake message follows
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Handshake Header</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<ul>
			<li><tt>02</tt> - handshake message type 0x02 (server hello)
			<li><tt>%1 %2 %3</tt> - %xxx1 (%ddd1) bytes of server hello data follows
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Server Version</span>
		<span class="bytes">
%next 2
%bytes
		</span>
		<div class="explanation">
			A protocol version of 3.3 (meaning TLS 1.2)
			is given.  Because middleboxes have been
			created and widely deployed that do not
			allow protocol versions that
			they do not recognize, the TLS 1.3 session
			must be disguised as a TLS 1.2 session.
			This field is no
			longer used for version negotiation and
			is hardcoded to the 1.2 version.  Instead
			version negotiation is performed using the
			"Supported Versions" extension below.
			<br/><br/>
			The particular version number (3.3 representing
			version 1.2) is due to TLS 1.0 being a minor
			revision of the SSL 3.0 protocol.  Therefore
			TLS 1.0 is numeric version 3.1, TLS 1.1 is version
			3.2, and so on.
		</div>
	</span>

	<span class="string">
		<span class="label">Server Random</span>
		<span class="bytes">
%next 32
%bytes
		</span>
		<div class="explanation">
			The server provides 32 bytes of random data.
			In this example we've made the random data a predictable string.
		</div>
	</span>

	<span class="string">
		<span class="label">Session ID</span>
		<span class="bytes">
%next 33
%bytes
		</span>
		<div class="explanation">
			This legacy field is no longer used to
			identify and re-use sessions.  Instead the
			server echos the session ID provided by the
			client, if any.
			<ul>
			<li><tt>%0</tt> - %x0 (%d0) bytes of session ID follow
			<li><tt>%1 %2 ... %-2 %-1</tt> - session ID copied from Client Hello
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Cipher Suite</span>
		<span class="bytes">
%next 2
%bytes
		</span>
		<div class="explanation">
			The server has selected cipher suite 0x1301
			(AES-128-GCM-SHA256) from the list of options given by the client.
		</div>
	</span>

	<span class="string">
		<span class="label">Compression Method</span>
		<span class="bytes">
%next 1
%bytes
		</span>
		<div class="explanation">
			The server has selected compression method
			0x00 ("Null", which performs no compression)
			from the list of options given by the client.
		</div>
	</span>

	<span class="string">
		<span class="label">Extensions Length</span>
		<span class="bytes">
%next 2
%bytes
		</span>
		<div class="explanation">
			The server has returned a list of extensions
			to the client.  Because the server is
			forbidden from replying with an extension
			that the client did not send in its hello
			message, the server knows that the client
			will understand and support all extensions listed.
			<ul>
			<li><tt>%0 %1</tt> - the extensions will take %xx0 (%dd0) bytes of data
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Extension - Key Share</span>
		<span class="bytes">
%next 40
%bytes
		</span>
		<div class="explanation">
			The server sends a public key using the algorithm
			of the public key sent by the client.  Once this is sent
			encryption keys can be calculated and the rest of the
			handshake will be encrypted,
			unlike previous protocol versions where the
			handshake was sent in the clear.
			<ul>
				<li><tt>00 33</tt> - assigned value for extension "Key Share"
				<li><tt>%2 %3</tt> - %xx2 (%dd2) bytes of extension data follows
				<li><tt>00 1d</tt> - assigned value for x25519 (key exchange via curve25519)
				<li><tt>%8 %9</tt> - %xx8 (%dd8) bytes of public key follows
				<li><tt>%10 %11 ... %-2 %-1</tt></l> public key
				<li><tt>%10 %11 ... %-2 %-1</tt></l> - public key from the step "Server Key Exchange Generation"
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Extension - Supported Versions</span>
		<span class="bytes">
%next 6
%bytes
		</span>
		<div class="explanation">
			The server indicates the negotiated TLS version of 1.3.
			<ul>
				<li><tt>00 2b</tt> - assigned value for extension "Supported Versions"
				<li><tt>%2 %3</tt> - %xx2 (%dd2) bytes of extension data follows
				<li><tt>03 04</tt> - assigned value for TLS 1.3
			</ul>
		</div>
	</span>
</span>
</div>
</div>
%empty

<div class="rec-outer">
<div class="calculation server">
<div class="rec-label">Server Handshake Keys Calc</div>
<img class="illustration" src="images/key9.png" width="97" height="250"/>
<div class="rec-explanation">
	The server now has the information to calculate the
	keys used to encrypt the rest of the handshake.  It uses the following
	information in this calculation:
	<ul>
	<li><a href="files/client-ephemeral-public.key">client public key</a> (from Client Hello)
	<li><a href="files/server-ephemeral-private.key">server private key</a> (from Server Key Exchange Generation)
	<li>SHA256 hash of ClientHello and ServerHello</li>
	</ul>
	First, the server finds the shared secret, which is the
	result of the key exchange that allows the client and server
	to agree on a number.  The server multiplies the client's
	public key with the server's private key using the curve25519()
	algorithm.  The 32-byte result is found to be:
	<pre class="ind2"><tt class="longboi">df4a291baa1eb7cfa6934b29b474baad2697e29f1f920dcc77c8a0a088447624</tt></pre>

	I've provided <a href="files/curve25519-mult.c" download="curve25519-mult.c">a tool</a>
	to perform this calculation:
	<codesample>
<pre><code>$ cc -o curve25519-mult curve25519-mult.c
$ ./curve25519-mult server-ephemeral-private.key \
                    client-ephemeral-public.key | hexdump

0000000 df 4a 29 1b aa 1e b7 cf a6 93 4b 29 b4 74 ba ad
0000010 26 97 e2 9f 1f 92 0d cc 77 c8 a0 a0 88 44 76 24
</code></pre>
	</codesample>

	We then calculate the SHA256 hash of all handshake messages
	to this point (ClientHello and ServerHello).  The hash does
	not include the 5-byte "record" headers.  This "hello_hash"
	is <tt class="longboi">da75ce1139ac80dae4044da932350cf65c97ccc9e33f1e6f7d2d4b18b736ffd5</tt>.
	<br/><br/>

	We then feed the hash and the shared secret into a set of
	key derivation operations, designed to ensure the integrity
	of the handshake process and to protect against known and
	possible attacks:

	<processblock>
<pre>early_secret = HKDF-Extract(
    salt=00,
    key=00...)
empty_hash = SHA256("")
derived_secret = HKDF-Expand-Label(
    key = early_secret,
    label = "derived",
    context = empty_hash,
    len = 32)
handshake_secret = HKDF-Extract(
    salt = derived_secret,
    key = shared_secret)
client_handshake_traffic_secret = HKDF-Expand-Label(
    key = handshake_secret,
    label = "c hs traffic",
    context = hello_hash,
    len = 32)
server_handshake_traffic_secret = HKDF-Expand-Label(
    key = handshake_secret,
    label = "s hs traffic",
    context = hello_hash,
    len = 32)
client_handshake_key = HKDF-Expand-Label(
    key = client_handshake_traffic_secret,
    label = "key",
    context = "",
    len = 16)
server_handshake_key = HKDF-Expand-Label(
    key = server_handshake_traffic_secret,
    label = "key",
    context = "",
    len = 16)
client_handshake_iv = HKDF-Expand-Label(
    key = client_handshake_traffic_secret,
    label = "iv",
    context = "",
    len = 12)
server_handshake_iv = HKDF-Expand-Label(
    key = server_handshake_traffic_secret,
    label = "iv",
    context = "",
    len = 12)
</pre>
	</processblock>

	This has introduced two new cryptographic methods:
	<ul>
	<li><tt>HKDF-Extract</tt> - given a salt and some bytes of key material
	create 256 bits (32 bytes) of new key material, with the
	input key material's entropy evenly distributed in the
	output.
	<li><tt>HKDF-Expand-Label</tt> - given the inputs of key
	material, label, and context data, create a new key of the
	requested length.
	</ul>

	I've created <a href="files/hkdf.sh" download="hkdf">an HKDF tool</a>
	to perform these operations on the command line.
	<codesample>
<pre><code>$ hello_hash=da75ce1139ac80dae4044da932350cf65c97ccc9e33f1e6f7d2d4b18b736ffd5
$ shared_secret=df4a291baa1eb7cfa6934b29b474baad2697e29f1f920dcc77c8a0a088447624
$ zero_key=0000000000000000000000000000000000000000000000000000000000000000
$ early_secret=$(./hkdf extract 00 $zero_key)
$ empty_hash=$(openssl sha256 < /dev/null)
$ derived_secret=$(./hkdf expandlabel $early_secret "derived" $empty_hash 32)
$ handshake_secret=$(./hkdf extract $derived_secret $shared_secret)
$ csecret=$(./hkdf expandlabel $handshake_secret "c hs traffic" $hello_hash 32)
$ ssecret=$(./hkdf expandlabel $handshake_secret "s hs traffic" $hello_hash 32)
$ client_handshake_key=$(./hkdf expandlabel $csecret "key" "" 16)
$ server_handshake_key=$(./hkdf expandlabel $ssecret "key" "" 16)
$ client_handshake_iv=$(./hkdf expandlabel $csecret "iv" "" 12)
$ server_handshake_iv=$(./hkdf expandlabel $ssecret "iv" "" 12)
$ echo ckey: $client_handshake_key
$ echo skey: $server_handshake_key
$ echo civ: $client_handshake_iv
$ echo siv: $server_handshake_iv

ckey: 7154f314e6be7dc008df2c832baa1d39
skey: 844780a7acad9f980fa25c114e43402a
civ: 71abc2cae4c699d47c600268
siv: 4c042ddc120a38d1417fc815
</code></pre>
	</codesample>

	From this we get the following key data:
	<ul>
	<li>handshake secret: <tt class="longboi">fb9fc80689b3a5d02c33243bf69a1b1b20705588a794304a6e7120155edf149a</tt>
	<li>client handshake traffic secret: <tt class="longboi">ff0e5b965291c608c1e8cd267eefc0afcc5e98a2786373f0db47b04786d72aea</tt>.
	<li>server handshake traffic secret: <tt class="longboi">a2067265e7f0652a923d5d72ab0467c46132eeb968b6a32d311c805868548814</tt>.
	<li>client handshake key: <tt class="longboi">7154f314e6be7dc008df2c832baa1d39</tt>
	<li>server handshake key: <tt class="longboi">844780a7acad9f980fa25c114e43402a</tt>
	<li>client handshake IV: <tt class="longboi">71abc2cae4c699d47c600268</tt>
	<li>server handshake IV: <tt class="longboi">4c042ddc120a38d1417fc815</tt>
	</ul>
</div>
</div>
</div>

<div class="rec-outer">
<div class="calculation client">
<div class="rec-label">Client Handshake Keys Calc</div>
<img class="illustration" src="images/key8.png" width="97" height="250"/>
<div class="rec-explanation">
	The client now has the information to calculate the
	keys that used to encrypt the rest of the handshake.  It uses the following
	information in this calculation:
	<ul>
	<li><a href="files/server-ephemeral-public.key">server public key</a> (from Server Hello)
	<li><a href="files/client-ephemeral-private.key">client private key</a> (from Client Key Exchange Generation)
	<li>SHA256 hash of ClientHello and ServerHello</li>
	</ul>
	First, the client finds the shared secret, which is the
	result of the key exchange that allows the client and server
	to agree on a number.  The client multiplies the server's
	public key with the client's private key using the curve25519()
	algorithm.  The 32-byte result is found to be:
	<pre class="ind2"><tt class="longboi">df4a291baa1eb7cfa6934b29b474baad2697e29f1f920dcc77c8a0a088447624</tt></pre>

	I've provided <a href="files/curve25519-mult.c" download="curve25519-mult.c">a tool</a>
	to perform this calculation:
	<codesample>
<pre><code>$ cc -o curve25519-mult curve25519-mult.c
$ ./curve25519-mult client-ephemeral-private.key \
                    server-ephemeral-public.key | hexdump

0000000 df 4a 29 1b aa 1e b7 cf a6 93 4b 29 b4 74 ba ad
0000010 26 97 e2 9f 1f 92 0d cc 77 c8 a0 a0 88 44 76 24
</code></pre>
	</codesample>
	Since this is the same shared secret calculated by the
	server in "Server Handshake Keys Calc", the rest of
	the calculation is identical and the same values are found:
	<ul>
	<li>client handshake key: <tt class="longboi">7154f314e6be7dc008df2c832baa1d39</tt>
	<li>server handshake key: <tt class="longboi">844780a7acad9f980fa25c114e43402a</tt>
	<li>client handshake IV: <tt class="longboi">71abc2cae4c699d47c600268</tt>
	<li>server handshake IV: <tt class="longboi">4c042ddc120a38d1417fc815</tt>
	</ul>
</div>
</div>
</div>

<div class="rec-outer">
<div class="record server">
<div class="rec-label">Server Change Cipher Spec</div>
<div class="rec-explanation">
	This record is no longer needed.  In "middlebox compatibility
	mode" this record is sent to help disguise the session as
	a TLS 1.2 session.
</div>
%file ../captures/caps/serverccs
<span class="record-data">
	<span class="string">
		<span class="label">Record Header</span>
		<span class="bytes">
%next 6
%bytes
		</span>
		<div class="explanation">
			TLS sessions are broken into the sending
			and receiving of "records", which are blocks
			of data with a type, a protocol version,
			and a length.
			<ul>
			<li><tt>14</tt> - type is 0x14 (ChangeCipherSpec record)
			<li><tt>%1 %2</tt> - legacy protocol version of 3.3 (TLS 1.2)
			<li><tt>%3 %4</tt> - the length of the record payload is %xx3 (%dd3) bytes
			<li><tt>%5</tt> - the payload of this message is defined as the byte 0x01
			</ul>
		</div>
	</span>
</span>
</div>
</div>
%empty

<div class="rec-outer">
<div class="record server">
<div class="rec-label">Wrapper</div>
<img class="illustration" src="images/key5.png" width="124" height="250"/>
<div class="rec-explanation">
	The connection (including the handshake) is encrypted from
	this point on.  The encryption of handshake data is new in
	TLS 1.3.
	<br/><br/>
	To reduce issues with middleboxes that block unrecognized
	TLS protocols, the encrypted handshake is disguised as a
	TLS 1.2 session that has performed a successful session
	resume.
	<br/><br/>
	The wrapped records are discussed in their own sections below this one.
</div>
%file ../captures/caps/serverenchandshake
<span class="record-data">
	<span class="string">
		<span class="label">Record Header</span>
		<span class="bytes">
%next 5
%bytes
		</span>
		<div class="explanation">
			The TLS 1.3 records are encrypted into a
			TLS 1.2 record "wrapper" that looks like
			application data.
			<ul>
			<li><tt>%0</tt> - type is 0x17 (application data)
			<li><tt>%1 %2</tt> - legacy protocol version of 3.3 (TLS 1.2)
			<li><tt>%3 %4</tt> - %xx3 (%dd3) bytes of wrapped data follows
			</ul>
		</div>
	</span>

	<span class="string encrypted">
		<span class="label">Encrypted Data</span>
		<span class="bytes">
%next 1125
%bytes
		</span>
		<div class="explanation">
			This data is encrypted with the server handshake key.
		</div>
	</span>
	<span class="string">
		<span class="label">Auth Tag</span>
		<span class="bytes">
%next 16
%bytes
		</span>
		<div class="explanation">
			This is the AEAD authentication tag
			that protects the integrity of the
			encrypted data and the record header.
		</div>
	</span>
%empty

	<div class="decryption">
		<div class="label">Decryption</div>
		<div class="explanation">
			This data is encrypted using the server
			handshake key and the server handshake IV that were
			generated during the "Server Handshake Keys
			Calc" step.  The IV will be modified
			by XOR'ing it by the count of records that
			have already been encrypted with this key,
			which in thise case is 0.  The process also
			takes as input the 5-byte record header
			that this record begins with, as authenticated
			data that must match for the decryption to
			succeed.
			<br/><br/>
			Because the <tt>openssl</tt> command line
			tool does not yet support AEAD ciphers,
			I've written command line tools to both
			<a href="files/aes_128_gcm_decrypt.c" download="aes_128_gcm_decrypt.c">decrypt</a>
			and <a href="files/aes_128_gcm_encrypt.c" download="aes_128_gcm_encrypt.c">encrypt</a>
			this data.
			<codesample>
<pre><code>### from the "Server Handshake Keys Calc" step
$ key=844780a7acad9f980fa25c114e43402a
$ iv=4c042ddc120a38d1417fc815
### from this record
$ recdata=1703030475
$ authtag=e08b0e455a350ae54d76349aa68c71ae
$ recordnum=0
### may need to add -I and -L flags for include and lib dirs
$ cc -o aes_128_gcm_decrypt aes_128_gcm_decrypt.c -lssl -lcrypto
$ echo "da 1e c2 d7 bd a8 eb f7 3e dd 50 10 fb a8 08 9f d4 26 b0 ea 1e
  ... snip ...
  ac 2d dd 1f 88 5d 42 ea 58 4c" | xxd -r -p > /tmp/msg1
$ cat /tmp/msg1 \
  | ./aes_128_gcm_decrypt $iv $recordnum $key $recdata $authtag \
  | hexdump -C

00000000  08 00 00 02 00 00 0b 00  03 2e 00 00 03 2a 00 03  |.............*..|
00000010  25 30 82 03 21 30 82 02  09 a0 03 02 01 02 02 08  |%0..!0..........|
00000020  15 5a 92 ad c2 04 8f 90  30 0d 06 09 2a 86 48 86  |.Z......0...*.H.|
... snip ...
</code></pre>
			</codesample>
		</div>
	</div>

%file ../captures/caps/serverhandshake
	<span class="string decrypted">
		<span class="label">Encrypted Extensions</span>
		<span class="bytes">
%next 6
%bytes
		</span>
		<div class="explanation">
			This handshake message is represented in its own section below.
		</div>
	</span>

	<span class="string decrypted">
		<span class="label">Server Certificate</span>
		<span class="bytes">
%next 818
%bytes
		</span>
		<div class="explanation">
			This handshake message is represented in its own section below.
		</div>
	</span>

	<span class="string decrypted">
		<span class="label">Server Certificate Verify</span>
		<span class="bytes">
%next 264
%bytes
		</span>
		<div class="explanation">
			This handshake message is represented in its own section below.
		</div>
	</span>

	<span class="string decrypted">
		<span class="label">Server Finished</span>
		<span class="bytes">
%next 36
%bytes
		</span>
		<div class="explanation">
			This handshake message is represented in its own section below.
		</div>
	</span>

	<span class="string decrypted">
		<span class="label">Record Type</span>
		<span class="bytes">
%next 1
%bytes
		</span>
		<div class="explanation">
			Each TLS 1.3 record disguised as TLS 1.2
			application data has a final byte
			which indicates its actual record type.
			<ul>
			<li><tt>%0</tt> - type is 0x16 (handshake record)
			</ul>
		</div>
	</span>
</span>
</div>
</div>
%empty

<div class="rec-outer">
<div class="record server embedded">
<div class="rec-label">Server Encrypted Extensions</div>
<div class="rec-explanation">
	Any extensions that aren't needed for negotiating encryption
	keys should be listed here so they can be hidden from
	eavesdroppers and middleboxes.
</div>
%file ../captures/caps/serverencryptedextensions
<span class="record-data">
	<span class="string">
		<span class="label">Handshake Header</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<ul>
			<li><tt>%0</tt> - handshake message type 0x08 (encrypted extensions)
			<li><tt>%1 %2 %3</tt> - %xxx1 (%ddd1) bytes of handshake message data follows
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Extensions</span>
		<span class="bytes">
%next 2
%bytes
		</span>
		<div class="explanation">
			<ul>
			<li><tt>%0 %1</tt> - %xx0 (%dd0) bytes of extension data follows
			</ul>
		</div>
	</span>
</span>
</div>
</div>
%empty

<div class="rec-outer">
<div class="record server embedded">
<div class="rec-label">Server Certificate</div>
<img class="illustration" src="images/key3.png" width="130" height="250"/>
<div class="rec-explanation">
	The server provides a certificate containing the following:
	<ul>
	<li>the hostname of the server
	<li>the public key used by this server
	<li>proof from a trusted third party that the owner of this hostname holds the private key for this public key
	</ul>
	<a href="certificate.html" target="_blank">Explore the server certificate</a>.
</div>
%file ../captures/caps/servercert
<span class="record-data">
	<span class="string">
		<span class="label">Handshake Header</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<ul>
			<li><tt>%0</tt> - handshake message type 0x0B (certificate)
			<li><tt>%1 %2 %3</tt> - %xxx1 (%ddd1) bytes of certificate payload follow
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Request Context</span>
		<span class="bytes">
%next 1
%bytes
		</span>
		<div class="explanation">
			This record is empty because this certificate was not sent in
			response to a Certificate Request.
			<ul>
			<li><tt>%0</tt> - %x0 (%d0) bytes of request context follows
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Certificates Length</span>
		<span class="bytes">
%next 3
%bytes
		</span>
		<div class="explanation">
			<ul>
			<li><tt>%0 %1 %2</tt> - %xxx0 (%ddd0) bytes of certificates follow
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Certificate Length</span>
		<span class="bytes">
%next 3
%bytes
		</span>
		<div class="explanation">
			The length of the first (and only) certificate.
			<ul>
			<li><tt>%0 %1 %2</tt> - %xxx0 (%ddd0) bytes of certificate follows
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Certificate</span>
		<span class="bytes">
%next 805
%bytes
		</span>
		<div class="explanation">
			The certificate is in ASN.1 DER
			encoding.  The details of this format and
			the content of this binary payload are
			documented <a href="certificate.html" target="_blank">on another page</a>.
			<a href="files/server.crt" download="server.crt">The certificate</a>
			can be converted to the binary data in this message
			at the command line:
			<codesample>
<pre><code>$ openssl x509 -outform der &lt; server.crt | hexdump

0000000 30 82 03 21 30 82 02 09 a0 03 02 01 02 02 08 15
0000010 5a 92 ad c2 04 8f 90 30 0d 06 09 2a 86 48 86 f7
... snip ...
</code></pre>
			</codesample>
		</div>
	</span>

	<span class="string">
		<span class="label">Certificate Extensions</span>
		<span class="bytes">
%next 2
%bytes
		</span>
		<div class="explanation">
			The server can provide extension data for the certificate.
			<ul>
			<li><tt>%0 %1</tt> - %xx0 (%dd0) bytes of extension data follows
			</ul>
		</div>
	</span>
</span>
</div>
</div>
%empty

<div class="rec-outer">
<div class="record server embedded">
<div class="rec-label">Server Certificate Verify</div>
<div class="rec-explanation">
	The server provides information that ties the public key
	generated during Server Key Exchange Generation to the
	ownership of the certificate's private key.
</div>
%file ../captures/caps/servercertverify
<span class="record-data">
	<span class="string">
		<span class="label">Handshake Header</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<ul>
			<li><tt>%0</tt> - handshake message type 0x0f (certificate verify)
			<li><tt>%1 %2 %3</tt> - %xxx1 (%ddd1) bytes of handshake message data follows
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Signature</span>
		<span class="bytes">
%next 260
%bytes
		</span>
		<div class="explanation">
			Because the server is generating ephemeral
			keys for each session (optional in TLS 1.2,
			mandatory in TLS 1.3) the session is not
			inherently tied to the certificate as it
			was in previous versions of TLS, when the
			certificate's public/private key were used
			for key exchange.
			<br/><br/>
			To prove
			that the server owns the server certificate
			(giving the certificate validity in this
			TLS session), it signs a hash of the handshake
			messages using the certificate's private
			key.  The signature can be proven valid by
			the client by using the certificate's public
			key.
			<ul>
			<li><tt>08 04</tt> - reserved value for RSA-PSS-RSAE-SHA256 signature
			<li><tt>%2 %3</tt> - %xx2 (%dd2) bytes of signature data follows
			<li><tt>%4 %5 %6 ... %-3 %-2 %-1</tt> - a signature over this handshake's hash
			</ul>
			We can verify the signature ourselves using the
			<a href="files/server.crt" download="server.crt">server's certificate</a>
			at the command line:
			<codesample>
<pre><code>### build the data that was signed:
### 1. add 64 space characters
$ echo -n '                                ' > /tmp/tosign
$ echo -n '                                ' >> /tmp/tosign
### 2. add this fixed string
$ echo -n 'TLS 1.3, server CertificateVerify' >> /tmp/tosign
### 3. add a single null character
$ echo -en '\0' >> /tmp/tosign
### 4. add hash of handshake to this point
$ handshake_hash=3e66361ada42c7cb97f9a62b00cae1d8b584174c745f9a338cf9f7cdd51d15f8
$ echo $handshake_hash | xxd -r -p >> /tmp/tosign

### copy the signature that we want to verify
$ echo "17 fe b5 33 ca 6d 00 7d 00 58 25 79 68 42 4b bc 3a a6 90
  9e 9d 49 55 75 76 a5 20 e0 4a 5e f0 5f 0e 86 d2 4f f4 3f 8e b8 61
  ee f5 95 22 8d 70 32 aa 36 0f 71 4e 66 74 13 92 6e f4 f8 b5 80 3b
  69 e3 55 19 e3 b2 3f 43 73 df ac 67 87 06 6d cb 47 56 b5 45 60 e0
  88 6e 9b 96 2c 4a d2 8d ab 26 ba d1 ab c2 59 16 b0 9a f2 86 53 7f
  68 4f 80 8a ef ee 73 04 6c b7 df 0a 84 fb b5 96 7a ca 13 1f 4b 1c
  f3 89 79 94 03 a3 0c 02 d2 9c bd ad b7 25 12 db 9c ec 2e 5e 1d 00
  e5 0c af cf 6f 21 09 1e bc 4f 25 3c 5e ab 01 a6 79 ba ea be ed b9
  c9 61 8f 66 00 6b 82 44 d6 62 2a aa 56 88 7c cf c6 6a 0f 38 51 df
  a1 3a 78 cf f7 99 1e 03 cb 2c 3a 0e d8 7d 73 67 36 2e b7 80 5b 00
  b2 52 4f f2 98 a4 da 48 7c ac de af 8a 23 36 c5 63 1b 3e fa 93 5b
  b4 11 e7 53 ca 13 b0 15 fe c7 e4 a7 30 f1 36 9f 9e" | xxd -r -p > /tmp/sig

### extract the public key from the certificate
$ openssl x509 -pubkey -noout -in server.crt > server.pub

### verify the signature
$ cat /tmp/tosign | openssl dgst -verify server.pub -sha256 \
    -sigopt rsa_padding_mode:pss -sigopt rsa_pss_saltlen:-1 -signature /tmp/sig

Verified OK
</code></pre>
			</codesample>
		</div>
	</span>
</span>
</div>
</div>
%empty

<div class="rec-outer">
<div class="record server embedded">
<div class="rec-label">Server Handshake Finished</div>
<div class="rec-explanation">
	To verify that the handshake was successful and not tampered
	with, the server calculates verification data that client will agree on.
	The verification data is built from a hash of all handshake
	messages.
</div>
%file ../captures/caps/serverfinished
<span class="record-data">
	<span class="string">
		<span class="label">Handshake Header</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<ul>
			<li><tt>10</tt> - handshake message type 0x14 (finished)
			<li><tt>%1 %2 %3</tt> - %xxx1 (%ddd1) bytes of handshake finished data follows
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Verify Data</span>
		<span class="bytes">
%next 32
%bytes
		</span>
		<div class="explanation">
			The verify_data is built using the
			server_handshake_traffic_secret from
			the "Server Handshake Keys Calc" step and
			a SHA256 hash of every handshake record
			from Client Hello to Server Certificate
			Verify.

			<processblock class="notrunc">
<pre>finished_key = HKDF-Expand-Label(
    key = server_handshake_traffic_secret,
    label = "finished",
    context = "",
    len = 32)
finished_hash = SHA256(Client Hello ... Server Cert Verify)
verify_data = HMAC-SHA256(
	key = finished_key,
	msg = finished_hash)
</pre>
			</processblock>

			We can use <a href="files/hkdf.sh" download="hkdf">the HKDF
			tool</a> to reproduce this on the command line.
			<codesample>
<pre><code>$ sht_secret=a2067265e7f0652a923d5d72ab0467c46132eeb968b6a32d311c805868548814
$ fin_hash=0cd9871cd7a164dce9fbc7f96c0f2978417dfc0c728a3f2096a7de210991a865
$ fin_key=$(./hkdf expandlabel $sht_secret "finished" "" 32)
$ echo $fin_hash | xxd -r -p \
  | openssl dgst -sha256 -mac HMAC -macopt hexkey:$fin_key

ea6ee176dccc4af1859e9e4e93f797eac9a78ce439301e35275ad43f3cddbde3
</code></pre>
			</codesample>
		</div>
	</span>
</div>
</div>
%empty

<div class="rec-outer">
<div class="calculation server">
<div class="rec-label">Server Application Keys Calc</div>
<img class="illustration" src="images/key9.png" width="97" height="250"/>
<div class="rec-explanation">
	The server now has the information to calculate the
	keys used to encrypt application traffic.
	It uses the following information in this calculation:
	<ul>
	<li>The handshake secret (from "Server Handshake Key Calc")
	<li>The SHA256 hash of every handshake message from Client Hello to Server Handshake Finished</li>
	</ul>
	We calculate the SHA256 hash of all handshake messages to
	this point (Client Hello, Server Hello, Encrypted Extensions,
	Server Certificate, Server Certificate Verify, Server
	Finished).  The hash does not include any of the 5-byte
	"record" headers of ClientHello and ServerHello.  This
	"handshake_hash" is
	<tt class="longboi">22844b930e5e0a59a09d5ac35fc032fc91163b193874a265236e568077378d8b</tt>.
	<br/><br/>
	We then feed the hash and the handshake secret into a set of
	key derivation operations, designed to ensure the integrity
	of the handshake process and to protect against known and
	possible attacks:

	<processblock>
<pre>empty_hash = SHA256("")
derived_secret = HKDF-Expand-Label(
    key = handshake_secret,
    label = "derived",
    context = empty_hash,
    len = 32)
master_secret = HKDF-Extract(
    salt=derived_secret,
    key=00...)
client_application_traffic_secret = HKDF-Expand-Label(
    key = master_secret,
    label = "c ap traffic",
    context = handshake_hash,
    len = 32)
server_application_traffic_secret = HKDF-Expand-Label(
    key = master_secret,
    label = "s ap traffic",
    context = handshake_hash,
    len = 32)
client_application_key = HKDF-Expand-Label(
    key = client_application_traffic_secret,
    label = "key",
    context = "",
    len = 16)
server_application_key = HKDF-Expand-Label(
    key = server_application_traffic_secret,
    label = "key",
    context = "",
    len = 16)
client_application_iv = HKDF-Expand-Label(
    key = client_application_traffic_secret,
    label = "iv",
    context = "",
    len = 12)
server_application_iv = HKDF-Expand-Label(
    key = server_application_traffic_secret,
    label = "iv",
    context = "",
    len = 12)
</pre>
	</processblock>

	I've created <a href="files/hkdf.sh" download="hkdf">an HKDF tool</a>
	to perform these operations on the command line.
	<codesample>
<pre><code>$ handshake_hash=22844b930e5e0a59a09d5ac35fc032fc91163b193874a265236e568077378d8b
$ handshake_secret=fb9fc80689b3a5d02c33243bf69a1b1b20705588a794304a6e7120155edf149a
$ zero_key=0000000000000000000000000000000000000000000000000000000000000000
$ empty_hash=$(openssl sha256 < /dev/null)
$ derived_secret=$(./hkdf expandlabel $handshake_secret "derived" $empty_hash 32)
$ master_secret=$(./hkdf extract $derived_secret $zero_key)
$ csecret=$(./hkdf expandlabel $master_secret "c ap traffic" $handshake_hash 32)
$ ssecret=$(./hkdf expandlabel $master_secret "s ap traffic" $handshake_hash 32)
$ client_application_key=$(./hkdf expandlabel $csecret "key" "" 16)
$ server_application_key=$(./hkdf expandlabel $ssecret "key" "" 16)
$ client_application_iv=$(./hkdf expandlabel $csecret "iv" "" 12)
$ server_application_iv=$(./hkdf expandlabel $ssecret "iv" "" 12)
$ echo ckey: $client_application_key
$ echo skey: $server_application_key
$ echo civ: $client_application_iv
$ echo siv: $server_application_iv

ckey: 49134b95328f279f0183860589ac6707
skey: 0b6d22c8ff68097ea871c672073773bf
civ: bc4dd5f7b98acff85466261d
siv: 1b13dd9f8d8f17091d34b349
</code></pre>
	</codesample>

	From this we get the following key data:
	<ul>
	<li>client application key: <tt class="longboi">49134b95328f279f0183860589ac6707</tt>
	<li>server application key: <tt class="longboi">0b6d22c8ff68097ea871c672073773bf</tt>
	<li>client application IV: <tt class="longboi">bc4dd5f7b98acff85466261d</tt>
	<li>server application IV: <tt class="longboi">1b13dd9f8d8f17091d34b349</tt>
	</ul>
</div>
</div>

<div class="rec-outer">
<div class="calculation client">
<div class="rec-label">Client Application Keys Calc</div>
<img class="illustration" src="images/key7.png" width="97" height="250"/>
<div class="rec-explanation">
	The client now has the information to calculate the
	keys used to encrypt application traffic.
	It performs the same calculation shown in "Server Application
	Keys Calc" and finds the same values:
	<ul>
	<li>client application key: <tt class="longboi">49134b95328f279f0183860589ac6707</tt>
	<li>server application key: <tt class="longboi">0b6d22c8ff68097ea871c672073773bf</tt>
	<li>client application IV: <tt class="longboi">bc4dd5f7b98acff85466261d</tt>
	<li>server application IV: <tt class="longboi">1b13dd9f8d8f17091d34b349</tt>
	</ul>
</div>
</div>
</div>

<div class="rec-outer">
<div class="record client">
<div class="rec-label">Client Change Cipher Spec</div>
<div class="rec-explanation">
	This record is no longer needed.  In "middlebox compatibility
	mode" this record is sent to help disguise the encrypted
	handshake as a resumed TLS 1.2 session.
</div>
%file ../captures/caps/clientccs
<span class="record-data">
	<span class="string">
		<span class="label">Record Header</span>
		<span class="bytes">
%next 6
%bytes
		</span>
		<div class="explanation">
			TLS sessions are broken into the sending
			and receiving of "records", which are blocks
			of data with a type, a protocol version,
			and a length.
			<ul>
			<li><tt>14</tt> - type is 0x14 (ChangeCipherSpec record)
			<li><tt>%1 %2</tt> - legacy protocol version of 3.3 (TLS 1.2)
			<li><tt>%3 %4</tt> - the length of the record payload is %xx3 (%dd3) bytes
			<li><tt>%5</tt> - the payload of this message is defined as the byte 0x01
			</ul>
		</div>
	</span>
</span>
</div>
</div>
%empty

<div class="rec-outer">
<div class="record client">
<div class="rec-label">Wrapper</div>
<div class="rec-explanation">
	To reduce issues with middleboxes that block unrecognized
	TLS protocols, TLS 1.3 records are disguised as TLS 1.2
	records.
	<br/><br/>
	The wrapped record is discussed in its own section below this one.
</div>
%file ../captures/caps/clientfinished
<span class="record-data">
	<span class="string">
		<span class="label">Record Header</span>
		<span class="bytes">
%next 5
%bytes
		</span>
		<div class="explanation">
			The TLS 1.3 record is encrypted into a TLS
			1.2 record "wrapper" that looks like
			application data.
			<ul>
			<li><tt>%0</tt> - type is 0x17 (application data)
			<li><tt>%1 %2</tt> - legacy protocol version of 3.3 (TLS 1.2)
			<li><tt>%3 %4</tt> - %xx3 (%dd3) bytes of wrapped data follows
			</ul>
		</div>
	</span>

	<span class="string encrypted">
		<span class="label">Encrypted Data</span>
		<span class="bytes">
%next 37
%bytes
		</span>
		<div class="explanation">
			This data is encrypted with the client handshake key.
		</div>
	</span>
	<span class="string">
		<span class="label">Auth Tag</span>
		<span class="bytes">
%next 16
%bytes
		</span>
		<div class="explanation">
			This is the AEAD authentication tag
			that protects the integrity of the
			encrypted data and the record header.
		</div>
	</span>
%empty

%file ../captures/caps/clientfinishedplain
	<div class="decryption">
		<div class="label">Decryption</div>
		<div class="explanation">
			This data is encrypted using the client
			handshake key and the client handshake IV that were
			generated during the "Client Handshake Keys
			Calc" step.  The IV will be modified
			by XOR'ing it by the count of records that
			have already been encrypted with this key,
			which in thise case is 0.  The process also
			takes as input the 5-byte record header
			that this record begins with, as authenticated
			data that must match for the decryption to
			succeed.
			<br/><br/>
			Because the <tt>openssl</tt> command line
			tool does not yet support AEAD ciphers,
			I've written command line tools to both
			<a href="files/aes_128_gcm_decrypt.c" download="aes_128_gcm_decrypt.c">decrypt</a>
			and <a href="files/aes_128_gcm_encrypt.c" download="aes_128_gcm_encrypt.c">encrypt</a>
			this data.
			<codesample>
<pre><code>### from the "Client Handshake Keys Calc" step
$ key=7154f314e6be7dc008df2c832baa1d39
$ iv=71abc2cae4c699d47c600268
### from this record
$ recdata=1703030035
$ authtag=5435d4eb22d0536c80c932e2f3c96083
$ recordnum=0
### may need to add -I and -L flags for include and lib dirs
$ cc -o aes_128_gcm_decrypt aes_128_gcm_decrypt.c -lssl -lcrypto
$ echo "71 55 df f4 74 1b df c0 c4 3a 1d e0 b0 11 33 ac 19 74 ed c8 8e 70
  91 c3 ff 1e 26 60 cd 71 92 83 ba 40 f7 c1 0b" | xxd -r -p > /tmp/msg2
$ cat /tmp/msg2 \
  | ./aes_128_gcm_decrypt $iv $recordnum $key $recdata $authtag \
  | hexdump -C

00000000  14 00 00 20 97 60 17 a7  7a e4 7f 16 58 e2 8f 70  |... .`..z...X..p|
00000010  85 fe 37 d1 49 d1 e9 c9  1f 56 e1 ae bb e0 c6 bb  |..7.I....V......|
00000020  05 4b d9 2b 16                                    |.K.+.|
</code></pre>
			</codesample>
		</div>
	</div>

	<span class="string decrypted">
		<span class="label">Client Handshake Finished</span>
		<span class="bytes">
%next 36
%bytes
		</span>
		<div class="explanation">
			This handshake message is represented in its own section below.
		</div>
	</span>

	<span class="string decrypted">
		<span class="label">Record Type</span>
		<span class="bytes">
%next 1
%bytes
		</span>
		<div class="explanation">
			Each TLS 1.3 record disguised as TLS 1.2
			application data has a final non-zero byte
			which indicates its actual record type.
			<ul>
			<li><tt>%0</tt> - type is 0x16 (handshake record)
			</ul>
		</div>
	</span>
</div>
</div>
%empty

<div class="rec-outer">
<div class="record client embedded">
<div class="rec-label">Client Handshake Finished</div>
<div class="rec-explanation">
	To verify that the handshake was successful and not tampered
	with, the client calculates verification data that the
	server will agree on, and encrypts it with the client
	handshake key.  The verification data is built from a hash
	of all handshake messages.
</div>
%file ../captures/caps/clientfinishedplain
<span class="record-data">
	<span class="string">
		<span class="label">Handshake Header</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<ul>
			<li><tt>%0</tt> - handshake message type 0x14 (finished)
			<li><tt>%1 %2 %3</tt> - %xxx1 (%ddd1) bytes of handshake finished data follow
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Verify Data</span>
		<span class="bytes">
%next 32
%bytes
		</span>
		<div class="explanation">
			The verify_data is built using the
			client_handshake_traffic_secret from
			the "Server Handshake Keys Calc" step and
			a SHA256 hash of every handshake record
			from Client Hello to Server Finished.

			<processblock class="notrunc">
<pre>finished_key = HKDF-Expand-Label(
    key = client_handshake_traffic_secret,
    label = "finished",
    context = "",
    len = 32)
finished_hash = SHA256(Client Hello ... Server Finished)
verify_data = HMAC-SHA256(
	key = finished_key,
	msg = finished_hash)
</pre>
			</processblock>

			We can use <a href="files/hkdf.sh" download="hkdf">the HKDF
			tool</a> to reproduce this this on the command line.
			<codesample>
<pre><code>$ cht_secret=ff0e5b965291c608c1e8cd267eefc0afcc5e98a2786373f0db47b04786d72aea
$ fin_hash=22844b930e5e0a59a09d5ac35fc032fc91163b193874a265236e568077378d8b
$ fin_key=$(./hkdf expandlabel $cht_secret "finished" "" 32)
$ echo $fin_hash | xxd -r -p \
  | openssl dgst -sha256 -mac HMAC -macopt hexkey:$fin_key

976017a77ae47f1658e28f7085fe37d149d1e9c91f56e1aebbe0c6bb054bd92b
</code></pre>
			</codesample>
		</div>
	</span>
</div>
</div>
%next 1
%empty

<div class="rec-outer">
<div class="record client">
<div class="rec-label">Wrapper</div>
<div class="rec-explanation">
	To reduce issues with middleboxes that block unrecognized
	TLS protocols, TLS 1.3 records are disguised as TLS 1.2
	records.
	<br/><br/>
	The wrapped record is discussed in its own section below this one.
</div>
%file ../captures/caps/clientdata
<span class="record-data">
	<span class="string">
		<span class="label">Record Header</span>
		<span class="bytes">
%next 5
%bytes
		</span>
		<div class="explanation">
			The TLS 1.3 record is encrypted into a TLS
			1.2 record "wrapper" that looks like
			application data.
			<ul>
			<li><tt>%0</tt> - type is 0x17 (application data)
			<li><tt>%1 %2</tt> - legacy protocol version of 3.3 (TLS 1.2)
			<li><tt>%3 %4</tt> - the length of the record payload is %xx3 (%dd3) bytes
			</ul>
			All data following this header is the encrypted form of the actual record.
		</div>
	</span>

	<span class="string encrypted">
		<span class="label">Encrypted Data</span>
		<span class="bytes">
%next 5
%bytes
		</span>
		<div class="explanation">
			This data is encrypted with the client application key.
			<br/><br/>
			See below for the decrypted data.
		</div>
	</span>

	<span class="string">
		<span class="label">Auth Tag</span>
		<span class="bytes">
%next 16
%bytes
		</span>
		<div class="explanation">
			This is the AEAD authentication tag
			that protects the integrity of the
			encrypted data and the record header.
		</div>
	</span>
%empty

	<div class="decryption">
		<div class="label">Decryption</div>
		<div class="explanation">
			This data is encrypted using the client
			application key and the client application IV that were
			generated during the "Client Application Keys
			Calc" step.  The IV will be modified
			by XOR'ing it by the count of records that
			have already been encrypted with this key,
			which in thise case is 0.  The process also
			takes as input the 5-byte record header
			that this record begins with, as authenticated
			data that must match for the decryption to
			succeed.
			<br/><br/>
			Because the <tt>openssl</tt> command line
			tool does not yet support AEAD ciphers,
			I've written command line tools to both
			<a href="files/aes_128_gcm_decrypt.c" download="aes_128_gcm_decrypt.c">decrypt</a>
			and <a href="files/aes_128_gcm_encrypt.c" download="aes_128_gcm_encrypt.c">encrypt</a>
			this data.
			<codesample>
<pre><code>### from the "Client Application Keys Calc" step
$ key=49134b95328f279f0183860589ac6707
$ iv=bc4dd5f7b98acff85466261d
### from this record
$ recdata=1703030015
$ authtag=b12f5f25a781957874742ab7fb305dd5
$ recordnum=0
### may need to add -I and -L flags for include and lib dirs
$ cc -o aes_128_gcm_decrypt aes_128_gcm_decrypt.c -lssl -lcrypto
$ echo "c7 40 61 53 5e" \
  | xxd -r -p > /tmp/msg3
$ cat /tmp/msg3 \
  | ./aes_128_gcm_decrypt $iv $recordnum $key $recdata $authtag \
  | hexdump -C

00000000  70 69 6e 67 17                                    |ping.|
</code></pre>
			</codesample>
		</div>
	</div>

%file ../captures/caps/clientdataplain
	<span class="string decrypted">
		<span class="label">Client Application Data</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			This application data is represented in its own section below.
		</div>
	</span>

	<span class="string decrypted">
		<span class="label">Record Type</span>
		<span class="bytes">
%next 1
%bytes
		</span>
		<div class="explanation">
			Each TLS 1.3 record disguised as TLS 1.2
			application data has a final byte
			which indicates its actual record type.
			<ul>
			<li><tt>%0</tt> - type is 0x17 (application data)
			</ul>
		</div>
	</span>
</span>
</div>
</div>
%empty

<div class="rec-outer">
<div class="record client embedded">
<div class="rec-label">Client Application Data</div>
<div class="rec-explanation">
	The client sends the data "ping".
</div>
%file ../captures/caps/clientdataplain
<span class="record-data">
	<span class="string">
		<span class="label">Application Data</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			The bytes "ping".
		</div>
	</span>
</span>
</div>
</div>
%next 1
%empty

<div class="rec-outer">
<div class="record server">
<div class="rec-label">Wrapper</div>
<div class="rec-explanation">
	To reduce issues with middleboxes that block unrecognized
	TLS protocols, TLS 1.3 records are disguised as TLS 1.2
	records.
	<br/><br/>
	The wrapped records are discussed in their own sections below this one.
</div>
%file ../captures/caps/servertickets
<span class="record-data">
	<span class="string">
		<span class="label">Record Header</span>
		<span class="bytes">
%next 5
%bytes
		</span>
		<div class="explanation">
			The TLS 1.3 record is encrypted into a TLS
			1.2 record "wrapper" that looks like
			application data.
			<ul>
			<li><tt>%0</tt> - type is 0x17 (application data)
			<li><tt>%1 %2</tt> - legacy protocol version of 3.3 (TLS 1.2)
			<li><tt>%3 %4</tt> - the length of the record payload is %xx3 (%dd3) bytes
			</ul>
			All data following this header is the encrypted form of the actual record.
		</div>
	</span>

	<span class="string encrypted">
		<span class="label">Encrypted Data</span>
		<span class="bytes">
%next 365
%bytes
		</span>
		<div class="explanation">
			This data is encrypted with the server application key.
			<br/><br/>
			See below for the decrypted data.
		</div>
	</span>

	<span class="string">
		<span class="label">Auth Tag</span>
		<span class="bytes">
%next 16
%bytes
		</span>
		<div class="explanation">
			This is the AEAD authentication tag
			that protects the integrity of the
			encrypted data and the record header.
		</div>
	</span>
%empty

	<div class="decryption">
		<div class="label">Decryption</div>
		<div class="explanation">
			This data is encrypted using the server
			application key and the server application IV that were
			generated during the "Server Application Keys
			Calc" step.  The IV will be modified
			by XOR'ing it by the count of records that
			have already been encrypted with this key,
			which in thise case is 0.  The process also
			takes as input the 5-byte record header
			that this record begins with, as authenticated
			data that must match for the decryption to
			succeed.
			<br/><br/>
			Because the <tt>openssl</tt> command line
			tool does not yet support AEAD ciphers,
			I've written command line tools to both
			<a href="files/aes_128_gcm_decrypt.c" download="aes_128_gcm_decrypt.c">decrypt</a>
			and <a href="files/aes_128_gcm_encrypt.c" download="aes_128_gcm_encrypt.c">encrypt</a>
			this data.
			<codesample>
<pre><code>### from the "Server Application Keys Calc" step
$ key=0b6d22c8ff68097ea871c672073773bf
$ iv=1b13dd9f8d8f17091d34b349
### from this record
$ recdata=170303017d
$ authtag=bfe0c1f688627643a049c3492eaf6f0f
$ recordnum=0
### may need to add -I and -L flags for include and lib dirs
$ cc -o aes_128_gcm_decrypt aes_128_gcm_decrypt.c -lssl -lcrypto
$ echo "c4 d4 b7 1b 6f 4c 2f 30 13 02 74 e7 b4 6e 40 89 68 de 07 98 f3 60
  ... snip ... 
  9a 00 5f 88 e0 a2 da" | xxd -r -p > /tmp/msg5
$ cat /tmp/msg5 \
  | ./aes_128_gcm_decrypt $iv $recordnum $key $recdata $authtag \
  | hexdump -C

00000000  04 00 00 b2 00 02 a3 00  04 03 02 01 01 00 00 a0
... snip ...
</code></pre>
			</codesample>
		</div>
	</div>

%file ../captures/caps/serverticketsplain
	<span class="string decrypted">
		<span class="label">Server New Session Ticket 1</span>
		<span class="bytes">
%next 182
%bytes
		</span>
		<div class="explanation">
			This handshake message is represented in its own section below.
		</div>
	</span>

	<span class="string decrypted">
		<span class="label">Server New Session Ticket 2</span>
		<span class="bytes">
%next 182
%bytes
		</span>
		<div class="explanation">
			This handshake message is represented in its own section below.
		</div>
	</span>

	<span class="string decrypted">
		<span class="label">Record Type</span>
		<span class="bytes">
%next 1
%bytes
		</span>
		<div class="explanation">
			Each TLS 1.3 record disguised as TLS 1.2
			application data has a final byte
			which indicates its actual record type.
			<ul>
			<li><tt>%0</tt> - type is 0x16 (handshake data)
			</ul>
		</div>
	</span>
</span>
</div>
</div>
%empty

<div class="rec-outer">
<div class="record server embedded">
<div class="rec-label">Server New Session Ticket 1</div>
<div class="rec-explanation">
	The server provides a session ticket that the client can
	use to start a new session later.  Successfully resuming a
	connection in this way will skip most of the computation
	and network delay in session startup.
	<br/><br/>
	Because each session ticket is meant to be single-use, and
	because the server expects a browser to open multiple
	connections, it makes a size vs. speed decision to provide
	the client with two session tickets for each negotiated
	session.  This is the first ticket.
</div>
%file ../captures/caps/serverticket1
<span class="record-data">
	<span class="string">
		<span class="label">Handshake Header</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<ul>
			<li><tt>%0</tt> - handshake message type 0x04 (new session ticket)
			<li><tt>%1 %2 %3</tt> - %xxx1 (%ddd1) bytes of session ticket data follow
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Ticket Lifetime</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			The ticket lifetime of %xxxx0 (%dddd0) seconds, or 2 days.
		</div>
	</span>

	<span class="string">
		<span class="label">Ticket Age Add</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			When sending this ticket back to the server,
			it must add this number of milliseconds to
			the timestamp indicating when the ticket
			was generated.  This prevents attackers
			from correlating the resumed session with
			the session that generated this ticket.
		</div>
	</span>

	<span class="string">
		<span class="label">Ticket Nonce</span>
		<span class="bytes">
%next 2
%bytes
		</span>
		<div class="explanation">
			A per-ticket value that is unique to each
			ticket generated during this session.
			<ul>
			<li><tt>%0</tt> - %x0 (%d0) bytes of nonce data follows
			<li><tt>%1</tt> - nonce value of %d1
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Session Ticket</span>
		<span class="bytes">
%next 162
%bytes
		</span>
		<div class="explanation">
			This is the ticket that can be sent to the
			server to resume a session.  The data inside
			is probably meaningful to the server, and
			may contain enough information for the
			server to safely resume the connection
			without storing any information on the
			server (such as in memory).  This information
			is not meaningful or understandable to the
			client.

			<ul>
			<li><tt>%0 %1</tt> - %xx0 (%dd0) bytes of ticket data follows
			<li><tt>%2 %3 ... %-2 %-1</tt> - session ticket
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Ticket Extensions</span>
		<span class="bytes">
%next 6
%bytes
		</span>
		<div class="explanation">
			The server provides an extension to provide
			more information about the ticket or to
			request a behavioral change from the client.
			<br/><br/>
			Interestingly this is not an actual extension
			but is random data created as part of the
			<a href="https://tools.ietf.org/html/draft-davidben-tls-grease-01">GREASE</a>
			scheme to prevent badly written
			software from rejecting unrecognized values.
			<ul>
			<li><tt>%0 %1</tt> - %xx0 (%dd0) bytes of extension data follows
			<li><tt>%2 %3</tt> - the randomly generated extension type
			<li><tt>%4 %5</tt> - %xx4 (%dd4) bytes of data are in the first extension
			</ul>
		</div>
	</span>
</span>
</div>
</div>
%empty

<div class="rec-outer">
<div class="record server embedded">
<div class="rec-label">Server New Session Ticket 2</div>
<div class="rec-explanation">
	The server provides a session ticket that the client can
	use to start a new session later.  Successfully resuming a
	connection in this way will skip most of the computation
	and network delay in session startup.
	<br/><br/>
	Because each session ticket is meant to be single-use, and
	because the server expects a browser to open multiple
	connections, it makes a size vs. speed decision to provide
	the client with two session tickets for each negotiated
	session.  This is the second ticket.
</div>
%file ../captures/caps/serverticket2
<span class="record-data">
	<span class="string">
		<span class="label">Handshake Header</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			Each handshake message starts with a type and a length.
			<ul>
			<li><tt>%0</tt> - handshake message type 0x04 (new session ticket)
			<li><tt>%1 %2 %3</tt> - %xxx1 (%ddd1) bytes of session ticket data follow
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Ticket Lifetime</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			The ticket lifetime of %xxxx0 (%dddd0) seconds, or 2 days.
		</div>
	</span>

	<span class="string">
		<span class="label">Ticket Age Add</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			When sending this ticket back to the server,
			it must add this number of milliseconds to
			the timestamp indicating when the ticket
			was generated.  This prevents attackers
			from correlating the resumed session with
			the session that generated this ticket.
		</div>
	</span>

	<span class="string">
		<span class="label">Ticket Nonce</span>
		<span class="bytes">
%next 2
%bytes
		</span>
		<div class="explanation">
			A per-ticket value that is unique to each
			ticket generated during this session.
			<ul>
			<li><tt>%0</tt> - %x0 (%d0) bytes of nonce data follows
			<li><tt>%1</tt> - nonce value of %d1
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Session Ticket</span>
		<span class="bytes">
%next 162
%bytes
		</span>
		<div class="explanation">
			This is the ticket that can be sent to the
			server to resume a session.  The data inside
			is probably meaningful to the server, and
			may contain enough information for the
			server to safely resume the connection
			without storing any information on the
			server (such as in memory).  This information
			is not meaningful or understandable to the
			client.

			<ul>
			<li><tt>%0 %1</tt> - %xx0 (%dd0) bytes of ticket data follows
			<li><tt>%2 %3 ... %-2 %-1</tt> - session ticket
			</ul>
		</div>
	</span>

	<span class="string">
		<span class="label">Ticket Extensions</span>
		<span class="bytes">
%next 6
%bytes
		</span>
		<div class="explanation">
			The server provides an extension to provide
			more information about the ticket or to
			request a behavioral change from the client.
			<br/><br/>
			Interestingly this is not an actual extension
			but is random data created as part of the
			<a href="https://tools.ietf.org/html/draft-davidben-tls-grease-01">GREASE</a>
			scheme to prevent badly written
			software from rejecting unrecognized values.
			<ul>
			<li><tt>%0 %1</tt> - %xx0 (%dd0) bytes of extension data follows
			<li><tt>%2 %3</tt> - the randomly generated extension type
			<li><tt>%4 %5</tt> - %xx4 (%dd4) bytes of data are in the first extension
			</ul>
		</div>
	</span>
</span>
</div>
</div>
%empty

<div class="rec-outer">
<div class="record server">
<div class="rec-label">Wrapper</div>
<div class="rec-explanation">
	To reduce issues with middleboxes that block unrecognized
	TLS protocols, TLS 1.3 records are disguised as TLS 1.2
	records.
	<br/><br/>
	The wrapped record is discussed in its own section below this one.
</div>
%file ../captures/caps/serverdata
<span class="record-data">
	<span class="string">
		<span class="label">Record Header</span>
		<span class="bytes">
%next 5
%bytes
		</span>
		<div class="explanation">
			The TLS 1.3 record is encrypted into a TLS
			1.2 record "wrapper" that looks like
			application data.
			<ul>
			<li><tt>%0</tt> - type is 0x17 (application data)
			<li><tt>%1 %2</tt> - legacy protocol version of 3.3 (TLS 1.2)
			<li><tt>%3 %4</tt> - the length of the record payload is %xx3 (%dd3) bytes
			</ul>
			All data following this header is the encrypted form of the actual record.
		</div>
	</span>

	<span class="string encrypted">
		<span class="label">Encrypted Data</span>
		<span class="bytes">
%next 5
%bytes
		</span>
		<div class="explanation">
			This data is encrypted with the server application key.
			<br/><br/>
			See below for the decrypted data.
		</div>
	</span>

	<span class="string">
		<span class="label">Auth Tag</span>
		<span class="bytes">
%next 16
%bytes
		</span>
		<div class="explanation">
			This is the AEAD authentication tag
			that protects the integrity of the
			encrypted data and the record header.
		</div>
	</span>
%empty

	<div class="decryption">
		<div class="label">Decryption</div>
		<div class="explanation">
			This data is encrypted using the server
			application key and the server application IV that were
			generated during the "Server Application Keys
			Calc" step.  The IV will be modified
			by XOR'ing it by the count of records that
			have already been encrypted with this key,
			which in thise case is 1.  The process also
			takes as input the 5-byte record header
			that this record begins with, as authenticated
			data that must match for the decryption to
			succeed.
			<br/><br/>
			Because the <tt>openssl</tt> command line
			tool does not yet support AEAD ciphers,
			I've written command line tools to both
			<a href="files/aes_128_gcm_decrypt.c" download="aes_128_gcm_decrypt.c">decrypt</a>
			and <a href="files/aes_128_gcm_encrypt.c" download="aes_128_gcm_encrypt.c">encrypt</a>
			this data.
			<codesample>
<pre><code>### from the "Server Application Keys Calc" step
$ key=0b6d22c8ff68097ea871c672073773bf
$ iv=1b13dd9f8d8f17091d34b349
### from this record
$ recdata=1703030015
$ authtag=fa7fb16b663ecdfca3dbb81931a90ca7
$ recordnum=1
### may need to add -I and -L flags for include and lib dirs
$ cc -o aes_128_gcm_decrypt aes_128_gcm_decrypt.c -lssl -lcrypto
$ echo "370e5f168a" | xxd -r -p > /tmp/msg4
$ cat /tmp/msg4 \
  | ./aes_128_gcm_decrypt $iv $recordnum $key $recdata $authtag \
  | hexdump -C

00000000  70 6f 6e 67 17                                    |pong.|
</code></pre>
			</codesample>
		</div>
	</div>

%file ../captures/caps/serverdataplain
	<span class="string decrypted">
		<span class="label">Server Application Data</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			This application data is represented in its own section below.
		</div>
	</span>

	<span class="string decrypted">
		<span class="label">Record Type</span>
		<span class="bytes">
%next 1
%bytes
		</span>
		<div class="explanation">
			Each TLS 1.3 record disguised as TLS 1.2
			application data has a final byte
			which indicates its actual record type.
			<ul>
			<li><tt>%0</tt> - type is 0x17 (application data)
			</ul>
		</div>
	</span>
</span>
</div>
</div>
%empty

<div class="rec-outer">
<div class="record server embedded">
<div class="rec-label">Server Application Data</div>
<div class="rec-explanation">
	The server sends the data "pong".
</div>
%file ../captures/caps/serverdataplain
<span class="record-data">
	<span class="string">
		<span class="label">Application Data</span>
		<span class="bytes">
%next 4
%bytes
		</span>
		<div class="explanation">
			The bytes "pong".
		</div>
	</span>
</span>
</div>
</div>
%next 1
%empty

	<div class="outerblock">
	<p>The code for this project can be found
	<a href="https://github.com/syncsynchalt/illustrated-tls13">on GitHub</a>.</p>
	</div>

	<div class="outerblock">
	<p>You may also be interested in the
	<a href="https://tls.ulfheim.net/">TLS 1.2</a> version of this document.</p>
	</div>

	<div class="outerblock">
	<p>If you found this page useful or interesting let me know via Twitter
	<a href="https://twitter.com/xargsnotbombs">@XargsNotBombs</a>.</p>
	</div>

</div>

<div id="templates" style="display: none">
	<div id="closeBtnTmpl">
		<span class="close" onclick="ill.unselectAllStrings()"></span>
	</div>
	<div id="showCodeTmpl">
		<button class="show-code" onclick="ill.showCode(this, event)">Show Code</button>
	</div>
	<button id="annotateTmpl" class="annotate-toggle"
		onclick="ill.toggleAnnotate(this.parentElement, event)">Annotations</button>
</div>

<a class="print-mode" href="#print" onclick="ill.printMode()">
	[print]
</a>
</body>
</html>
